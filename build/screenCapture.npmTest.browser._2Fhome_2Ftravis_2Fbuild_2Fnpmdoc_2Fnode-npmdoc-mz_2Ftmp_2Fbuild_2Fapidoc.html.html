<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/normalize/mz#readme">mz (v2.6.0)</a>
</h1>
<h4>modernize node.js to current ECMAScript standards</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz">module mz</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess">
            function <span class="apidocSignatureSpan">mz.</span>child_process.ChildProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Certificate">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Certificate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Cipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Cipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Decipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Decipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman">
            function <span class="apidocSignatureSpan">mz.</span>crypto.DiffieHellman
            <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Hash
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Hmac
            <span class="apidocSignatureSpan">(hmac, key, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Sign">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Sign
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Verify">
            function <span class="apidocSignatureSpan">mz.</span>crypto.Verify
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman">
            function <span class="apidocSignatureSpan">mz.</span>crypto.getDiffieHellman
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream">
            function <span class="apidocSignatureSpan">mz.</span>fs.ReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats">
            function <span class="apidocSignatureSpan">mz.</span>fs.Stats
            <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream">
            function <span class="apidocSignatureSpan">mz.</span>fs.WriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.Interface">
            function <span class="apidocSignatureSpan">mz.</span>readline.Interface
            <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate">
            function <span class="apidocSignatureSpan">mz.</span>zlib.Deflate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.DeflateRaw">
            function <span class="apidocSignatureSpan">mz.</span>zlib.DeflateRaw
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gunzip">
            function <span class="apidocSignatureSpan">mz.</span>zlib.Gunzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gzip">
            function <span class="apidocSignatureSpan">mz.</span>zlib.Gzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Inflate">
            function <span class="apidocSignatureSpan">mz.</span>zlib.Inflate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.InflateRaw">
            function <span class="apidocSignatureSpan">mz.</span>zlib.InflateRaw
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Unzip">
            function <span class="apidocSignatureSpan">mz.</span>zlib.Unzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib">
            function <span class="apidocSignatureSpan">mz.</span>zlib.Zlib
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>child_process.ChildProcess.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Certificate.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Cipher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Cipheriv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Decipher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Decipheriv.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.DiffieHellman.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Hash.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Hmac.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Sign.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.Verify.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>crypto.getDiffieHellman.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>fs.ReadStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>fs.Stats.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>fs.WriteStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>readline.Interface.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>zlib.Deflate.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.</span>zlib.Zlib.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.child_process">module mz.child_process</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess">
            function <span class="apidocSignatureSpan">mz.child_process.</span>ChildProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process._forkChild">
            function <span class="apidocSignatureSpan">mz.child_process.</span>_forkChild
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.exec">
            function <span class="apidocSignatureSpan">mz.child_process.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.execFile">
            function <span class="apidocSignatureSpan">mz.child_process.</span>execFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.execFileSync">
            function <span class="apidocSignatureSpan">mz.child_process.</span>execFileSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.execSync">
            function <span class="apidocSignatureSpan">mz.child_process.</span>execSync
            <span class="apidocSignatureSpan">(command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.fork">
            function <span class="apidocSignatureSpan">mz.child_process.</span>fork
            <span class="apidocSignatureSpan">(modulePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.spawn">
            function <span class="apidocSignatureSpan">mz.child_process.</span>spawn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.spawnSync">
            function <span class="apidocSignatureSpan">mz.child_process.</span>spawnSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.child_process.ChildProcess">module mz.child_process.ChildProcess</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess.ChildProcess">
            function <span class="apidocSignatureSpan">mz.child_process.</span>ChildProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess.super_">
            function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.child_process.ChildProcess.prototype">module mz.child_process.ChildProcess.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess.prototype.kill">
            function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>kill
            <span class="apidocSignatureSpan">(sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess.prototype.ref">
            function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>ref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess.prototype.spawn">
            function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>spawn
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.child_process.ChildProcess.prototype.unref">
            function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>unref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto">module mz.crypto</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Certificate">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Certificate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Cipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Cipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Decipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Decipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman">
            function <span class="apidocSignatureSpan">mz.crypto.</span>DiffieHellman
            <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellmanGroup">
            function <span class="apidocSignatureSpan">mz.crypto.</span>DiffieHellmanGroup
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Hash
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Hmac
            <span class="apidocSignatureSpan">(hmac, key, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Sign">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Sign
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Verify">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Verify
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto._toBuf">
            function <span class="apidocSignatureSpan">mz.crypto.</span>_toBuf
            <span class="apidocSignatureSpan">(str, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createCipher">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createCipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createCipheriv">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createCipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createDecipher">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createDecipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createDecipheriv">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createDecipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createDiffieHellman">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createDiffieHellman
            <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createDiffieHellmanGroup">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createDiffieHellmanGroup
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createECDH">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createECDH
            <span class="apidocSignatureSpan">(curve)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createHash">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createHash
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createHmac">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createHmac
            <span class="apidocSignatureSpan">(hmac, key, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createSign">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createSign
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.createVerify">
            function <span class="apidocSignatureSpan">mz.crypto.</span>createVerify
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getCiphers">
            function <span class="apidocSignatureSpan">mz.crypto.</span>getCiphers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getCurves">
            function <span class="apidocSignatureSpan">mz.crypto.</span>getCurves
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman">
            function <span class="apidocSignatureSpan">mz.crypto.</span>getDiffieHellman
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getHashes">
            function <span class="apidocSignatureSpan">mz.crypto.</span>getHashes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.pbkdf2">
            function <span class="apidocSignatureSpan">mz.crypto.</span>pbkdf2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.pbkdf2Sync">
            function <span class="apidocSignatureSpan">mz.crypto.</span>pbkdf2Sync
            <span class="apidocSignatureSpan">(password, salt, iterations, keylen, digest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.privateDecrypt">
            function <span class="apidocSignatureSpan">mz.crypto.</span>privateDecrypt
            <span class="apidocSignatureSpan">(options, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.privateEncrypt">
            function <span class="apidocSignatureSpan">mz.crypto.</span>privateEncrypt
            <span class="apidocSignatureSpan">(options, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.prng">
            function <span class="apidocSignatureSpan">mz.crypto.</span>prng
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.pseudoRandomBytes">
            function <span class="apidocSignatureSpan">mz.crypto.</span>pseudoRandomBytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.publicDecrypt">
            function <span class="apidocSignatureSpan">mz.crypto.</span>publicDecrypt
            <span class="apidocSignatureSpan">(options, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.publicEncrypt">
            function <span class="apidocSignatureSpan">mz.crypto.</span>publicEncrypt
            <span class="apidocSignatureSpan">(options, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.randomBytes">
            function <span class="apidocSignatureSpan">mz.crypto.</span>randomBytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.rng">
            function <span class="apidocSignatureSpan">mz.crypto.</span>rng
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.setEngine">
            function <span class="apidocSignatureSpan">mz.crypto.</span>setEngine
            <span class="apidocSignatureSpan">(id, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.timingSafeEqual">
            function <span class="apidocSignatureSpan">mz.crypto.</span>timingSafeEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.crypto.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.crypto.</span>DEFAULT_ENCODING</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Certificate">module mz.crypto.Certificate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Certificate.Certificate">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Certificate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Certificate.prototype">module mz.crypto.Certificate.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Certificate.prototype.exportChallenge">
            function <span class="apidocSignatureSpan">mz.crypto.Certificate.prototype.</span>exportChallenge
            <span class="apidocSignatureSpan">(object, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Certificate.prototype.exportPublicKey">
            function <span class="apidocSignatureSpan">mz.crypto.Certificate.prototype.</span>exportPublicKey
            <span class="apidocSignatureSpan">(object, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Certificate.prototype.verifySpkac">
            function <span class="apidocSignatureSpan">mz.crypto.Certificate.prototype.</span>verifySpkac
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Cipher">module mz.crypto.Cipher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.Cipher">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Cipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Cipher.prototype">module mz.crypto.Cipher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype._flush">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype._transform">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype.final">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>final
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype.getAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>getAuthTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype.setAAD">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>setAAD
            <span class="apidocSignatureSpan">(aadbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype.setAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>setAuthTag
            <span class="apidocSignatureSpan">(tagbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype.setAutoPadding">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>setAutoPadding
            <span class="apidocSignatureSpan">(ap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipher.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>update
            <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Cipheriv">module mz.crypto.Cipheriv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.Cipheriv">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Cipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Cipheriv.prototype">module mz.crypto.Cipheriv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype._flush">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype._transform">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype.final">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>final
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype.getAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>getAuthTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype.setAAD">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>setAAD
            <span class="apidocSignatureSpan">(aadbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype.setAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>setAuthTag
            <span class="apidocSignatureSpan">(tagbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype.setAutoPadding">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>setAutoPadding
            <span class="apidocSignatureSpan">(ap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Cipheriv.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>update
            <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Decipher">module mz.crypto.Decipher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.Decipher">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Decipher
            <span class="apidocSignatureSpan">(cipher, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Decipher.prototype">module mz.crypto.Decipher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype._flush">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype._transform">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype.final">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>final
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype.finaltol">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>finaltol
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype.getAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>getAuthTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype.setAAD">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>setAAD
            <span class="apidocSignatureSpan">(aadbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype.setAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>setAuthTag
            <span class="apidocSignatureSpan">(tagbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype.setAutoPadding">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>setAutoPadding
            <span class="apidocSignatureSpan">(ap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipher.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>update
            <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Decipheriv">module mz.crypto.Decipheriv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.Decipheriv">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Decipheriv
            <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Decipheriv.prototype">module mz.crypto.Decipheriv.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype._flush">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype._transform">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype.final">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>final
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype.finaltol">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>finaltol
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype.getAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>getAuthTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype.setAAD">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>setAAD
            <span class="apidocSignatureSpan">(aadbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype.setAuthTag">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>setAuthTag
            <span class="apidocSignatureSpan">(tagbuf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype.setAutoPadding">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>setAutoPadding
            <span class="apidocSignatureSpan">(ap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Decipheriv.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>update
            <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.DiffieHellman">module mz.crypto.DiffieHellman</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.DiffieHellman">
            function <span class="apidocSignatureSpan">mz.crypto.</span>DiffieHellman
            <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.DiffieHellman.prototype">module mz.crypto.DiffieHellman.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.computeSecret">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>computeSecret
            <span class="apidocSignatureSpan">(key, inEnc, outEnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.generateKeys">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>generateKeys
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getGenerator">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getGenerator
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getPrime">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getPrime
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getPrivateKey">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getPrivateKey
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getPublicKey">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getPublicKey
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.setPrivateKey">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>setPrivateKey
            <span class="apidocSignatureSpan">(key, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.DiffieHellman.prototype.setPublicKey">
            function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>setPublicKey
            <span class="apidocSignatureSpan">(key, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Hash">module mz.crypto.Hash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash.Hash">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Hash
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Hash.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Hash.prototype">module mz.crypto.Hash.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash.prototype._flush">
            function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash.prototype._transform">
            function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash.prototype.digest">
            function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>digest
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hash.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>update
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Hmac">module mz.crypto.Hmac</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac.Hmac">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Hmac
            <span class="apidocSignatureSpan">(hmac, key, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Hmac.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Hmac.prototype">module mz.crypto.Hmac.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac.prototype._flush">
            function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac.prototype._transform">
            function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac.prototype.digest">
            function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>digest
            <span class="apidocSignatureSpan">(outputEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Hmac.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>update
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Sign">module mz.crypto.Sign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Sign.Sign">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Sign
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Sign.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Sign.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Sign.prototype">module mz.crypto.Sign.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Sign.prototype._write">
            function <span class="apidocSignatureSpan">mz.crypto.Sign.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Sign.prototype.sign">
            function <span class="apidocSignatureSpan">mz.crypto.Sign.prototype.</span>sign
            <span class="apidocSignatureSpan">(options, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Sign.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Sign.prototype.</span>update
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Verify">module mz.crypto.Verify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Verify.Verify">
            function <span class="apidocSignatureSpan">mz.crypto.</span>Verify
            <span class="apidocSignatureSpan">(algorithm, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Verify.super_">
            function <span class="apidocSignatureSpan">mz.crypto.Verify.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.Verify.prototype">module mz.crypto.Verify.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Verify.prototype._write">
            function <span class="apidocSignatureSpan">mz.crypto.Verify.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Verify.prototype.update">
            function <span class="apidocSignatureSpan">mz.crypto.Verify.prototype.</span>update
            <span class="apidocSignatureSpan">(data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.Verify.prototype.verify">
            function <span class="apidocSignatureSpan">mz.crypto.Verify.prototype.</span>verify
            <span class="apidocSignatureSpan">(object, signature, sigEncoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.getDiffieHellman">module mz.crypto.getDiffieHellman</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman.getDiffieHellman">
            function <span class="apidocSignatureSpan">mz.crypto.</span>getDiffieHellman
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.crypto.getDiffieHellman.prototype">module mz.crypto.getDiffieHellman.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.computeSecret">
            function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>computeSecret
            <span class="apidocSignatureSpan">(key, inEnc, outEnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.generateKeys">
            function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>generateKeys
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getGenerator">
            function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getGenerator
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getPrime">
            function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getPrime
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getPrivateKey">
            function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getPrivateKey
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getPublicKey">
            function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getPublicKey
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.dns">module mz.dns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.getServers">
            function <span class="apidocSignatureSpan">mz.dns.</span>getServers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.lookup">
            function <span class="apidocSignatureSpan">mz.dns.</span>lookup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.lookupService">
            function <span class="apidocSignatureSpan">mz.dns.</span>lookupService
            <span class="apidocSignatureSpan">(host, port, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolve">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolve4">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolve4
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolve6">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolve6
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolveCname">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolveCname
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolveMx">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolveMx
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolveNaptr">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolveNaptr
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolveNs">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolveNs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolvePtr">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolvePtr
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolveSoa">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolveSoa
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolveSrv">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolveSrv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.resolveTxt">
            function <span class="apidocSignatureSpan">mz.dns.</span>resolveTxt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.reverse">
            function <span class="apidocSignatureSpan">mz.dns.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.dns.setServers">
            function <span class="apidocSignatureSpan">mz.dns.</span>setServers
            <span class="apidocSignatureSpan">(servers)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.dns.</span>ADDRCONFIG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.dns.</span>V4MAPPED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>ADDRGETNETWORKPARAMS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>BADFAMILY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>BADFLAGS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>BADHINTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>BADNAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>BADQUERY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>BADRESP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>BADSTR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>CANCELLED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>CONNREFUSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>DESTRUCTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>EOF</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>FILE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>FORMERR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>LOADIPHLPAPI</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>NODATA</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>NOMEM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>NONAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>NOTFOUND</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>NOTIMP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>NOTINITIALIZED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>REFUSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>SERVFAIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.dns.</span>TIMEOUT</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.fs">module mz.fs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.FileReadStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>FileReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.FileWriteStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>FileWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>ReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats">
            function <span class="apidocSignatureSpan">mz.fs.</span>Stats
            <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>WriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs._toUnixTimestamp">
            function <span class="apidocSignatureSpan">mz.fs.</span>_toUnixTimestamp
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.access">
            function <span class="apidocSignatureSpan">mz.fs.</span>access
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.accessSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>accessSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.appendFile">
            function <span class="apidocSignatureSpan">mz.fs.</span>appendFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.appendFileSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>appendFileSync
            <span class="apidocSignatureSpan">(path, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.chmod">
            function <span class="apidocSignatureSpan">mz.fs.</span>chmod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.chmodSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>chmodSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.chown">
            function <span class="apidocSignatureSpan">mz.fs.</span>chown
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.chownSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>chownSync
            <span class="apidocSignatureSpan">(path, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.close">
            function <span class="apidocSignatureSpan">mz.fs.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.closeSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>closeSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.createReadStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>createReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.createWriteStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>createWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.exists">
            function <span class="apidocSignatureSpan">mz.fs.</span>exists
            <span class="apidocSignatureSpan">(filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.existsSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>existsSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fchmod">
            function <span class="apidocSignatureSpan">mz.fs.</span>fchmod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fchmodSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>fchmodSync
            <span class="apidocSignatureSpan">(fd, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fchown">
            function <span class="apidocSignatureSpan">mz.fs.</span>fchown
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fchownSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>fchownSync
            <span class="apidocSignatureSpan">(fd, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fdatasync">
            function <span class="apidocSignatureSpan">mz.fs.</span>fdatasync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fdatasyncSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>fdatasyncSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fstat">
            function <span class="apidocSignatureSpan">mz.fs.</span>fstat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fstatSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>fstatSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fsync">
            function <span class="apidocSignatureSpan">mz.fs.</span>fsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.fsyncSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>fsyncSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ftruncate">
            function <span class="apidocSignatureSpan">mz.fs.</span>ftruncate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ftruncateSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>ftruncateSync
            <span class="apidocSignatureSpan">(fd, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.futimes">
            function <span class="apidocSignatureSpan">mz.fs.</span>futimes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.futimesSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>futimesSync
            <span class="apidocSignatureSpan">(fd, atime, mtime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.link">
            function <span class="apidocSignatureSpan">mz.fs.</span>link
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.linkSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>linkSync
            <span class="apidocSignatureSpan">(existingPath, newPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.lstat">
            function <span class="apidocSignatureSpan">mz.fs.</span>lstat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.lstatSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>lstatSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.mkdir">
            function <span class="apidocSignatureSpan">mz.fs.</span>mkdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.mkdirSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>mkdirSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.mkdtemp">
            function <span class="apidocSignatureSpan">mz.fs.</span>mkdtemp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.mkdtempSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>mkdtempSync
            <span class="apidocSignatureSpan">(prefix, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.open">
            function <span class="apidocSignatureSpan">mz.fs.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.openSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>openSync
            <span class="apidocSignatureSpan">(path, flags, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.read">
            function <span class="apidocSignatureSpan">mz.fs.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.readFile">
            function <span class="apidocSignatureSpan">mz.fs.</span>readFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.readFileSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>readFileSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.readSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>readSync
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.readdir">
            function <span class="apidocSignatureSpan">mz.fs.</span>readdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.readdirSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>readdirSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.readlink">
            function <span class="apidocSignatureSpan">mz.fs.</span>readlink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.readlinkSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>readlinkSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.realpath">
            function <span class="apidocSignatureSpan">mz.fs.</span>realpath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.realpathSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>realpathSync
            <span class="apidocSignatureSpan">(p, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.rename">
            function <span class="apidocSignatureSpan">mz.fs.</span>rename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.renameSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>renameSync
            <span class="apidocSignatureSpan">(oldPath, newPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.rmdir">
            function <span class="apidocSignatureSpan">mz.fs.</span>rmdir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.rmdirSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>rmdirSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.stat">
            function <span class="apidocSignatureSpan">mz.fs.</span>stat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.statSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>statSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.symlink">
            function <span class="apidocSignatureSpan">mz.fs.</span>symlink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.symlinkSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>symlinkSync
            <span class="apidocSignatureSpan">(target, path, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.truncate">
            function <span class="apidocSignatureSpan">mz.fs.</span>truncate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.truncateSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>truncateSync
            <span class="apidocSignatureSpan">(path, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.unlink">
            function <span class="apidocSignatureSpan">mz.fs.</span>unlink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.unlinkSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>unlinkSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.unwatchFile">
            function <span class="apidocSignatureSpan">mz.fs.</span>unwatchFile
            <span class="apidocSignatureSpan">(filename, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.utimes">
            function <span class="apidocSignatureSpan">mz.fs.</span>utimes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.utimesSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>utimesSync
            <span class="apidocSignatureSpan">(path, atime, mtime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.watch">
            function <span class="apidocSignatureSpan">mz.fs.</span>watch
            <span class="apidocSignatureSpan">(filename, options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.watchFile">
            function <span class="apidocSignatureSpan">mz.fs.</span>watchFile
            <span class="apidocSignatureSpan">(filename, options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.write">
            function <span class="apidocSignatureSpan">mz.fs.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.writeFile">
            function <span class="apidocSignatureSpan">mz.fs.</span>writeFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.writeFileSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>writeFileSync
            <span class="apidocSignatureSpan">(path, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.writeSync">
            function <span class="apidocSignatureSpan">mz.fs.</span>writeSync
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.fs.</span>F_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.fs.</span>R_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.fs.</span>W_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.fs.</span>X_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.fs.</span>constants</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.fs.ReadStream">module mz.fs.ReadStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream.ReadStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>ReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream.super_">
            function <span class="apidocSignatureSpan">mz.fs.ReadStream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.fs.ReadStream.prototype">module mz.fs.ReadStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream.prototype._read">
            function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>_read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream.prototype.close">
            function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream.prototype.destroy">
            function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.ReadStream.prototype.open">
            function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.fs.Stats">module mz.fs.Stats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.Stats">
            function <span class="apidocSignatureSpan">mz.fs.</span>Stats
            <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.fs.Stats.prototype">module mz.fs.Stats.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype._checkModeProperty">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>_checkModeProperty
            <span class="apidocSignatureSpan">(property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype.isBlockDevice">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isBlockDevice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype.isCharacterDevice">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isCharacterDevice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype.isDirectory">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isDirectory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype.isFIFO">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isFIFO
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype.isFile">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype.isSocket">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.Stats.prototype.isSymbolicLink">
            function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isSymbolicLink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.fs.WriteStream">module mz.fs.WriteStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.WriteStream">
            function <span class="apidocSignatureSpan">mz.fs.</span>WriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.super_">
            function <span class="apidocSignatureSpan">mz.fs.WriteStream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.fs.WriteStream.prototype">module mz.fs.WriteStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.prototype._write">
            function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>_write
            <span class="apidocSignatureSpan">(data, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.prototype._writev">
            function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>_writev
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.prototype.close">
            function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.prototype.destroy">
            function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.prototype.destroySoon">
            function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>destroySoon
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.fs.WriteStream.prototype.open">
            function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.readline">module mz.readline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.Interface">
            function <span class="apidocSignatureSpan">mz.readline.</span>Interface
            <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.clearLine">
            function <span class="apidocSignatureSpan">mz.readline.</span>clearLine
            <span class="apidocSignatureSpan">(stream, dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.clearScreenDown">
            function <span class="apidocSignatureSpan">mz.readline.</span>clearScreenDown
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.codePointAt">
            function <span class="apidocSignatureSpan">mz.readline.</span>codePointAt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.createInterface">
            function <span class="apidocSignatureSpan">mz.readline.</span>createInterface
            <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.cursorTo">
            function <span class="apidocSignatureSpan">mz.readline.</span>cursorTo
            <span class="apidocSignatureSpan">(stream, x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.emitKeypressEvents">
            function <span class="apidocSignatureSpan">mz.readline.</span>emitKeypressEvents
            <span class="apidocSignatureSpan">(stream, iface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.getStringWidth">
            function <span class="apidocSignatureSpan">mz.readline.</span>getStringWidth
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.isFullWidthCodePoint">
            function <span class="apidocSignatureSpan">mz.readline.</span>isFullWidthCodePoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.moveCursor">
            function <span class="apidocSignatureSpan">mz.readline.</span>moveCursor
            <span class="apidocSignatureSpan">(stream, dx, dy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.stripVTControlCharacters">
            function <span class="apidocSignatureSpan">mz.readline.</span>stripVTControlCharacters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.readline.Interface">module mz.readline.Interface</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.Interface.Interface">
            function <span class="apidocSignatureSpan">mz.readline.</span>Interface
            <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.readline.Interface.prototype">module mz.readline.Interface.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.readline.Interface.prototype.question">
            function <span class="apidocSignatureSpan">mz.readline.Interface.prototype.</span>question
            <span class="apidocSignatureSpan">(question, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib">module mz.zlib</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Deflate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.DeflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>DeflateRaw
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gunzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Gunzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Gzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Inflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Inflate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.InflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>InflateRaw
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Unzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Unzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Zlib
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.createDeflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>createDeflate
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.createDeflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>createDeflateRaw
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.createGunzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>createGunzip
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.createGzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>createGzip
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.createInflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>createInflate
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.createInflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>createInflateRaw
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.createUnzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>createUnzip
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.deflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>deflate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.deflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>deflateRaw
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.deflateRawSync">
            function <span class="apidocSignatureSpan">mz.zlib.</span>deflateRawSync
            <span class="apidocSignatureSpan">(buffer, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.deflateSync">
            function <span class="apidocSignatureSpan">mz.zlib.</span>deflateSync
            <span class="apidocSignatureSpan">(buffer, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.gunzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>gunzip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.gunzipSync">
            function <span class="apidocSignatureSpan">mz.zlib.</span>gunzipSync
            <span class="apidocSignatureSpan">(buffer, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.gzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>gzip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.gzipSync">
            function <span class="apidocSignatureSpan">mz.zlib.</span>gzipSync
            <span class="apidocSignatureSpan">(buffer, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.inflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>inflate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.inflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>inflateRaw
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.inflateRawSync">
            function <span class="apidocSignatureSpan">mz.zlib.</span>inflateRawSync
            <span class="apidocSignatureSpan">(buffer, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.inflateSync">
            function <span class="apidocSignatureSpan">mz.zlib.</span>inflateSync
            <span class="apidocSignatureSpan">(buffer, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.unzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>unzip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.unzipSync">
            function <span class="apidocSignatureSpan">mz.zlib.</span>unzipSync
            <span class="apidocSignatureSpan">(buffer, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>ZLIB_VERNUM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_BEST_COMPRESSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_BEST_SPEED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_BLOCK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_BUF_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_DATA_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_DEFAULT_CHUNK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_DEFAULT_COMPRESSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_DEFAULT_LEVEL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_DEFAULT_MEMLEVEL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_DEFAULT_STRATEGY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_DEFAULT_WINDOWBITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_ERRNO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_FILTERED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_FINISH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_FIXED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_FULL_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_HUFFMAN_ONLY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MAX_CHUNK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MAX_LEVEL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MAX_MEMLEVEL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MAX_WINDOWBITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MEM_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MIN_CHUNK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MIN_LEVEL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MIN_MEMLEVEL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_MIN_WINDOWBITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_NEED_DICT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_NO_COMPRESSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_NO_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_PARTIAL_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_RLE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_STREAM_END</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_STREAM_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_SYNC_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mz.zlib.</span>Z_VERSION_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mz.zlib.</span>codes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mz.zlib.</span>ZLIB_VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Deflate">module mz.zlib.Deflate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.Deflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Deflate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.</span>super_
            <span class="apidocSignatureSpan">(opts, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Deflate.super_.prototype">module mz.zlib.Deflate.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_.prototype._flush">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_.prototype._processChunk">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>_processChunk
            <span class="apidocSignatureSpan">(chunk, flushFlag, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_.prototype._transform">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_.prototype.close">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_.prototype.flush">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>flush
            <span class="apidocSignatureSpan">(kind, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_.prototype.params">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>params
            <span class="apidocSignatureSpan">(level, strategy, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Deflate.super_.prototype.reset">
            function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.DeflateRaw">module mz.zlib.DeflateRaw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.DeflateRaw.DeflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>DeflateRaw
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.DeflateRaw.super_">
            function <span class="apidocSignatureSpan">mz.zlib.DeflateRaw.</span>super_
            <span class="apidocSignatureSpan">(opts, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Gunzip">module mz.zlib.Gunzip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gunzip.Gunzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Gunzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gunzip.super_">
            function <span class="apidocSignatureSpan">mz.zlib.Gunzip.</span>super_
            <span class="apidocSignatureSpan">(opts, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Gzip">module mz.zlib.Gzip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gzip.Gzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Gzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Gzip.super_">
            function <span class="apidocSignatureSpan">mz.zlib.Gzip.</span>super_
            <span class="apidocSignatureSpan">(opts, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Inflate">module mz.zlib.Inflate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Inflate.Inflate">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Inflate
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Inflate.super_">
            function <span class="apidocSignatureSpan">mz.zlib.Inflate.</span>super_
            <span class="apidocSignatureSpan">(opts, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.InflateRaw">module mz.zlib.InflateRaw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.InflateRaw.InflateRaw">
            function <span class="apidocSignatureSpan">mz.zlib.</span>InflateRaw
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.InflateRaw.super_">
            function <span class="apidocSignatureSpan">mz.zlib.InflateRaw.</span>super_
            <span class="apidocSignatureSpan">(opts, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Unzip">module mz.zlib.Unzip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Unzip.Unzip">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Unzip
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Unzip.super_">
            function <span class="apidocSignatureSpan">mz.zlib.Unzip.</span>super_
            <span class="apidocSignatureSpan">(opts, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Zlib">module mz.zlib.Zlib</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib.Zlib">
            function <span class="apidocSignatureSpan">mz.zlib.</span>Zlib
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mz.zlib.Zlib.prototype">module mz.zlib.Zlib.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib.prototype.close">
            function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib.prototype.init">
            function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib.prototype.params">
            function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib.prototype.reset">
            function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib.prototype.write">
            function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mz.zlib.Zlib.prototype.writeSync">
            function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>writeSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz" id="apidoc.module.mz">module mz</a></h1>


    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess" id="apidoc.element.mz.child_process.ChildProcess">
        function <span class="apidocSignatureSpan">mz.</span>child_process.ChildProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ChildProcess() {
  EventEmitter.call(this);

  var self = this;

  this._closesNeeded = 1;
  this._closesGot = 0;
  this.connected = false;

  this.signalCode = null;
  this.exitCode = null;
  this.killed = false;
  this.spawnfile = null;

  this._handle = new Process();
  this._handle.owner = this;

  this._handle.onexit = function(exitCode, signalCode) {
    //
    // follow 0.4.x behaviour:
    //
    // - normally terminated processes don't touch this.signalCode
    // - signaled processes don't touch this.exitCode
    //
    // new in 0.9.x:
    //
    // - spawn failures are reported with exitCode &lt; 0
    //
    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';
    var err = (exitCode &lt; 0) ? errnoException(exitCode, syscall) : null;

    if (signalCode) {
      self.signalCode = signalCode;
    } else {
      self.exitCode = exitCode;
    }

    if (self.stdin) {
      self.stdin.destroy();
    }

    self._handle.close();
    self._handle = null;

    if (exitCode &lt; 0) {
      if (self.spawnfile)
        err.path = self.spawnfile;

      err.spawnargs = self.spawnargs.slice(1);
      self.emit('error', err);
    } else {
      self.emit('exit', self.exitCode, self.signalCode);
    }

    // if any of the stdio streams have not been touched,
    // then pull all the data through so that it can get the
    // eof and emit a 'close' event.
    // Do it on nextTick so that the user has one last chance
    // to consume the output, if for example they only want to
    // start reading the data once the process exits.
    process.nextTick(flushStdio, self);

    maybeClose(self);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Certificate" id="apidoc.element.mz.crypto.Certificate">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Certificate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Certificate() {
  if (!(this instanceof Certificate))
    return new Certificate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher" id="apidoc.element.mz.crypto.Cipher">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Cipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipher(cipher, password, options) {
  if (!(this instanceof Cipher))
    return new Cipher(cipher, password, options);
  this._handle = new binding.CipherBase(true);

  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv" id="apidoc.element.mz.crypto.Cipheriv">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Cipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipheriv(cipher, key, iv, options) {
  if (!(this instanceof Cipheriv))
    return new Cipheriv(cipher, key, iv, options);
  this._handle = new binding.CipherBase(true);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher" id="apidoc.element.mz.crypto.Decipher">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Decipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipher(cipher, password, options) {
  if (!(this instanceof Decipher))
    return new Decipher(cipher, password, options);

  this._handle = new binding.CipherBase(false);
  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv" id="apidoc.element.mz.crypto.Decipheriv">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Decipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipheriv(cipher, key, iv, options) {
  if (!(this instanceof Decipheriv))
    return new Decipheriv(cipher, key, iv, options);

  this._handle = new binding.CipherBase(false);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman" id="apidoc.element.mz.crypto.DiffieHellman">
        function <span class="apidocSignatureSpan">mz.</span>crypto.DiffieHellman
        <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {
  if (!(this instanceof DiffieHellman))
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);

  if (!(sizeOrKey instanceof Buffer) &amp;&amp;
      typeof sizeOrKey !== 'number' &amp;&amp;
      typeof sizeOrKey !== 'string')
    throw new TypeError('First argument should be number, string or Buffer');

  if (keyEncoding) {
    if (typeof keyEncoding !== 'string' ||
        (!Buffer.isEncoding(keyEncoding) &amp;&amp; keyEncoding !== 'buffer')) {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
  }

  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;
  genEncoding = genEncoding || exports.DEFAULT_ENCODING;

  if (typeof sizeOrKey !== 'number')
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);

  if (!generator)
    generator = DH_GENERATOR;
  else if (typeof generator !== 'number')
    generator = toBuf(generator, genEncoding);

  this._handle = new binding.DiffieHellman(sizeOrKey, generator);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hash" id="apidoc.element.mz.crypto.Hash">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Hash
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hash(algorithm, options) {
  if (!(this instanceof Hash))
    return new Hash(algorithm, options);
  this._handle = new binding.Hash(algorithm);
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac" id="apidoc.element.mz.crypto.Hmac">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Hmac
        <span class="apidocSignatureSpan">(hmac, key, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hmac(hmac, key, options) {
  if (!(this instanceof Hmac))
    return new Hmac(hmac, key, options);
  this._handle = new binding.Hmac();
  this._handle.init(hmac, toBuf(key));
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Sign" id="apidoc.element.mz.crypto.Sign">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Sign
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sign(algorithm, options) {
  if (!(this instanceof Sign))
    return new Sign(algorithm, options);
  this._handle = new binding.Sign();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Verify" id="apidoc.element.mz.crypto.Verify">
        function <span class="apidocSignatureSpan">mz.</span>crypto.Verify
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Verify(algorithm, options) {
  if (!(this instanceof Verify))
    return new Verify(algorithm, options);

  this._handle = new binding.Verify();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman" id="apidoc.element.mz.crypto.getDiffieHellman">
        function <span class="apidocSignatureSpan">mz.</span>crypto.getDiffieHellman
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this._handle = new binding.DiffieHellmanGroup(name);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream" id="apidoc.element.mz.fs.ReadStream">
        function <span class="apidocSignatureSpan">mz.</span>fs.ReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  // a little bit bigger buffer and water marks by default
  options = Object.create(options);
  if (options.highWaterMark === undefined)
    options.highWaterMark = 64 * 1024;

  Readable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'r' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  this.bytesRead = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== 'number') {
      throw new TypeError('"end" option must be a Number');
    }

    if (this.start &gt; this.end) {
      throw new Error('"start" option must be &lt;= "end" option');
    }

    this.pos = this.start;
  }

  if (typeof this.fd !== 'number')
    this.open();

  this.on('end', function() {
    if (this.autoClose) {
      this.destroy();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats" id="apidoc.element.mz.fs.Stats">
        function <span class="apidocSignatureSpan">mz.</span>fs.Stats
        <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = new Date(atim_msec);
  this.mtime = new Date(mtim_msec);
  this.ctime = new Date(ctim_msec);
  this.birthtime = new Date(birthtim_msec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream" id="apidoc.element.mz.fs.WriteStream">
        function <span class="apidocSignatureSpan">mz.</span>fs.WriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (!(this instanceof WriteStream))
    return new WriteStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  options = Object.create(options);

  Writable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'w' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
  this.pos = undefined;
  this.bytesWritten = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.start &lt; 0) {
      throw new Error('"start" must be &gt;= zero');
    }

    this.pos = this.start;
  }

  if (options.encoding)
    this.setDefaultEncoding(options.encoding);

  if (typeof this.fd !== 'number')
    this.open();

  // dispose on finish.
  this.once('finish', function() {
    if (this.autoClose) {
      this.close();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.Interface" id="apidoc.element.mz.readline.Interface">
        function <span class="apidocSignatureSpan">mz.</span>readline.Interface
        <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InterfaceAsPromised(input, output, completer, terminal) {
  if (arguments.length === 1) {
    var options = input

    if (typeof options.completer === 'function') {
      options = objectAssign({}, options, {
        completer: wrapCompleter(options.completer)
      })
    }

    Interface.call(this, options)
  } else {
    if (typeof completer === 'function') {
      completer = wrapCompleter(completer)
    }

    Interface.call(this, input, output, completer, terminal)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate" id="apidoc.element.mz.zlib.Deflate">
        function <span class="apidocSignatureSpan">mz.</span>zlib.Deflate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.DeflateRaw" id="apidoc.element.mz.zlib.DeflateRaw">
        function <span class="apidocSignatureSpan">mz.</span>zlib.DeflateRaw
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Gunzip" id="apidoc.element.mz.zlib.Gunzip">
        function <span class="apidocSignatureSpan">mz.</span>zlib.Gunzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Gzip" id="apidoc.element.mz.zlib.Gzip">
        function <span class="apidocSignatureSpan">mz.</span>zlib.Gzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Inflate" id="apidoc.element.mz.zlib.Inflate">
        function <span class="apidocSignatureSpan">mz.</span>zlib.Inflate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.InflateRaw" id="apidoc.element.mz.zlib.InflateRaw">
        function <span class="apidocSignatureSpan">mz.</span>zlib.InflateRaw
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Unzip" id="apidoc.element.mz.zlib.Unzip">
        function <span class="apidocSignatureSpan">mz.</span>zlib.Unzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib" id="apidoc.element.mz.zlib.Zlib">
        function <span class="apidocSignatureSpan">mz.</span>zlib.Zlib
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.child_process" id="apidoc.module.mz.child_process">module mz.child_process</a></h1>


    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess" id="apidoc.element.mz.child_process.ChildProcess">
        function <span class="apidocSignatureSpan">mz.child_process.</span>ChildProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ChildProcess() {
  EventEmitter.call(this);

  var self = this;

  this._closesNeeded = 1;
  this._closesGot = 0;
  this.connected = false;

  this.signalCode = null;
  this.exitCode = null;
  this.killed = false;
  this.spawnfile = null;

  this._handle = new Process();
  this._handle.owner = this;

  this._handle.onexit = function(exitCode, signalCode) {
    //
    // follow 0.4.x behaviour:
    //
    // - normally terminated processes don't touch this.signalCode
    // - signaled processes don't touch this.exitCode
    //
    // new in 0.9.x:
    //
    // - spawn failures are reported with exitCode &lt; 0
    //
    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';
    var err = (exitCode &lt; 0) ? errnoException(exitCode, syscall) : null;

    if (signalCode) {
      self.signalCode = signalCode;
    } else {
      self.exitCode = exitCode;
    }

    if (self.stdin) {
      self.stdin.destroy();
    }

    self._handle.close();
    self._handle = null;

    if (exitCode &lt; 0) {
      if (self.spawnfile)
        err.path = self.spawnfile;

      err.spawnargs = self.spawnargs.slice(1);
      self.emit('error', err);
    } else {
      self.emit('exit', self.exitCode, self.signalCode);
    }

    // if any of the stdio streams have not been touched,
    // then pull all the data through so that it can get the
    // eof and emit a 'close' event.
    // Do it on nextTick so that the user has one last chance
    // to consume the output, if for example they only want to
    // start reading the data once the process exits.
    process.nextTick(flushStdio, self);

    maybeClose(self);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process._forkChild" id="apidoc.element.mz.child_process._forkChild">
        function <span class="apidocSignatureSpan">mz.child_process.</span>_forkChild
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_forkChild = function (fd) {
  // set process.send()
  var p = new Pipe(true);
  p.open(fd);
  p.unref();
  const control = setupChannel(process, p);
  process.on('newListener', function(name) {
    if (name === 'message' || name === 'disconnect') control.ref();
  });
  process.on('removeListener', function(name) {
    if (name === 'message' || name === 'disconnect') control.unref();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.exec" id="apidoc.element.mz.child_process.exec">
        function <span class="apidocSignatureSpan">mz.child_process.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.execFile" id="apidoc.element.mz.child_process.execFile">
        function <span class="apidocSignatureSpan">mz.child_process.</span>execFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execFile = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.execFileSync" id="apidoc.element.mz.child_process.execFileSync">
        function <span class="apidocSignatureSpan">mz.child_process.</span>execFileSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function execFileSync() {
  var opts = normalizeSpawnArguments.apply(null, arguments);
  var inheritStderr = !opts.options.stdio;

  var ret = spawnSync(opts.file, opts.args.slice(1), opts.options);

  if (inheritStderr &amp;&amp; ret.stderr)
    process.stderr.write(ret.stderr);

  var err = checkExecSyncError(ret);

  if (err)
    throw err;
  else
    return ret.stdout;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.execSync" id="apidoc.element.mz.child_process.execSync">
        function <span class="apidocSignatureSpan">mz.child_process.</span>execSync
        <span class="apidocSignatureSpan">(command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function execSync(command) {
  var opts = normalizeExecArgs.apply(null, arguments);
  var inheritStderr = !opts.options.stdio;

  var ret = spawnSync(opts.file, opts.options);
  ret.cmd = command;

  if (inheritStderr &amp;&amp; ret.stderr)
    process.stderr.write(ret.stderr);

  var err = checkExecSyncError(ret);

  if (err)
    throw err;
  else
    return ret.stdout;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.fork" id="apidoc.element.mz.child_process.fork">
        function <span class="apidocSignatureSpan">mz.child_process.</span>fork
        <span class="apidocSignatureSpan">(modulePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fork = function (modulePath) {

  // Get options and args arguments.
  var options, args, execArgv;
  if (Array.isArray(arguments[1])) {
    args = arguments[1];
    options = util._extend({}, arguments[2]);
  } else if (arguments[1] &amp;&amp; typeof arguments[1] !== 'object') {
    throw new TypeError('Incorrect value of args option');
  } else {
    args = [];
    options = util._extend({}, arguments[1]);
  }

  // Prepare arguments for fork:
  execArgv = options.execArgv || process.execArgv;

  if (execArgv === process.execArgv &amp;&amp; process._eval != null) {
    const index = execArgv.lastIndexOf(process._eval);
    if (index &gt; 0) {
      // Remove the -e switch to avoid fork bombing ourselves.
      execArgv = execArgv.slice();
      execArgv.splice(index - 1, 2);
    }
  }

  args = execArgv.concat([modulePath], args);

  if (!Array.isArray(options.stdio)) {
    // Use a separate fd=3 for the IPC channel. Inherit stdin, stdout,
    // and stderr from the parent if silent isn't set.
    options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :
        [0, 1, 2, 'ipc'];
  } else if (options.stdio.indexOf('ipc') === -1) {
    throw new TypeError('Forked processes must have an IPC channel');
  }

  options.execPath = options.execPath || process.execPath;

  return spawn(options.execPath, args, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.spawn" id="apidoc.element.mz.child_process.spawn">
        function <span class="apidocSignatureSpan">mz.child_process.</span>spawn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spawn = function () {
  var opts = normalizeSpawnArguments.apply(null, arguments);
  var options = opts.options;
  var child = new ChildProcess();

  debug('spawn', opts.args, options);

  child.spawn({
    file: opts.file,
    args: opts.args,
    cwd: options.cwd,
    windowsVerbatimArguments: !!options.windowsVerbatimArguments,
    detached: !!options.detached,
    envPairs: opts.envPairs,
    stdio: options.stdio,
    uid: options.uid,
    gid: options.gid
  });

  return child;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.spawnSync" id="apidoc.element.mz.child_process.spawnSync">
        function <span class="apidocSignatureSpan">mz.child_process.</span>spawnSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spawnSync() {
  var opts = normalizeSpawnArguments.apply(null, arguments);

  var options = opts.options;

  var i;

  debug('spawnSync', opts.args, options);

  options.file = opts.file;
  options.args = opts.args;
  options.envPairs = opts.envPairs;

  if (options.killSignal)
    options.killSignal = lookupSignal(options.killSignal);

  options.stdio = _validateStdio(options.stdio || 'pipe', true).stdio;

  if (options.input) {
    var stdin = options.stdio[0] = util._extend({}, options.stdio[0]);
    stdin.input = options.input;
  }

  // We may want to pass data in on any given fd, ensure it is a valid buffer
  for (i = 0; i &lt; options.stdio.length; i++) {
    var input = options.stdio[i] &amp;&amp; options.stdio[i].input;
    if (input != null) {
      var pipe = options.stdio[i] = util._extend({}, options.stdio[i]);
      if (Buffer.isBuffer(input))
        pipe.input = input;
      else if (typeof input === 'string')
        pipe.input = Buffer.from(input, options.encoding);
      else
        throw new TypeError(util.format(
            'stdio[%d] should be Buffer or string not %s',
            i,
            typeof input));
    }
  }

  var result = spawn_sync.spawn(options);

  if (result.output &amp;&amp; options.encoding &amp;&amp; options.encoding !== 'buffer') {
    for (i = 0; i &lt; result.output.length; i++) {
      if (!result.output[i])
        continue;
      result.output[i] = result.output[i].toString(options.encoding);
    }
  }

  result.stdout = result.output &amp;&amp; result.output[1];
  result.stderr = result.output &amp;&amp; result.output[2];

  if (result.error) {
    result.error = errnoException(result.error, 'spawnSync ' + opts.file);
    result.error.path = opts.file;
    result.error.spawnargs = opts.args.slice(1);
  }

  util._extend(result, opts);

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.child_process.ChildProcess" id="apidoc.module.mz.child_process.ChildProcess">module mz.child_process.ChildProcess</a></h1>


    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess.ChildProcess" id="apidoc.element.mz.child_process.ChildProcess.ChildProcess">
        function <span class="apidocSignatureSpan">mz.child_process.</span>ChildProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ChildProcess() {
  EventEmitter.call(this);

  var self = this;

  this._closesNeeded = 1;
  this._closesGot = 0;
  this.connected = false;

  this.signalCode = null;
  this.exitCode = null;
  this.killed = false;
  this.spawnfile = null;

  this._handle = new Process();
  this._handle.owner = this;

  this._handle.onexit = function(exitCode, signalCode) {
    //
    // follow 0.4.x behaviour:
    //
    // - normally terminated processes don't touch this.signalCode
    // - signaled processes don't touch this.exitCode
    //
    // new in 0.9.x:
    //
    // - spawn failures are reported with exitCode &lt; 0
    //
    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';
    var err = (exitCode &lt; 0) ? errnoException(exitCode, syscall) : null;

    if (signalCode) {
      self.signalCode = signalCode;
    } else {
      self.exitCode = exitCode;
    }

    if (self.stdin) {
      self.stdin.destroy();
    }

    self._handle.close();
    self._handle = null;

    if (exitCode &lt; 0) {
      if (self.spawnfile)
        err.path = self.spawnfile;

      err.spawnargs = self.spawnargs.slice(1);
      self.emit('error', err);
    } else {
      self.emit('exit', self.exitCode, self.signalCode);
    }

    // if any of the stdio streams have not been touched,
    // then pull all the data through so that it can get the
    // eof and emit a 'close' event.
    // Do it on nextTick so that the user has one last chance
    // to consume the output, if for example they only want to
    // start reading the data once the process exits.
    process.nextTick(flushStdio, self);

    maybeClose(self);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess.super_" id="apidoc.element.mz.child_process.ChildProcess.super_">
        function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.child_process.ChildProcess.prototype" id="apidoc.module.mz.child_process.ChildProcess.prototype">module mz.child_process.ChildProcess.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess.prototype.kill" id="apidoc.element.mz.child_process.ChildProcess.prototype.kill">
        function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>kill
        <span class="apidocSignatureSpan">(sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (sig) {
  var signal;

  if (sig === 0) {
    signal = 0;
  } else if (!sig) {
    signal = constants['SIGTERM'];
  } else {
    signal = constants[sig];
  }

  if (signal === undefined) {
    throw new Error('Unknown signal: ' + sig);
  }

  if (this._handle) {
    var err = this._handle.kill(signal);
    if (err === 0) {
<span class="apidocCodeCommentSpan">      /* Success. */
</span>      this.killed = true;
      return true;
    }
    if (err === uv.UV_ESRCH) {
      /* Already dead. */
    } else if (err === uv.UV_EINVAL || err === uv.UV_ENOSYS) {
      /* The underlying platform doesn't support this signal. */
      throw errnoException(err, 'kill');
    } else {
      /* Other error, almost certainly EPERM. */
      this.emit('error', errnoException(err, 'kill'));
    }
  }

  /* Kill didn't succeed. */
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess.prototype.ref" id="apidoc.element.mz.child_process.ChildProcess.prototype.ref">
        function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>ref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ref = function () {
  if (this._handle) this._handle.ref();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess.prototype.spawn" id="apidoc.element.mz.child_process.ChildProcess.prototype.spawn">
        function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>spawn
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spawn = function (options) {
  const self = this;
  var ipc;
  var ipcFd;
  var i;
  // If no `stdio` option was given - use default
  var stdio = options.stdio || 'pipe';

  stdio = _validateStdio(stdio, false);

  ipc = stdio.ipc;
  ipcFd = stdio.ipcFd;
  stdio = options.stdio = stdio.stdio;

  if (ipc !== undefined) {
    // Let child process know about opened IPC channel
    options.envPairs = options.envPairs || [];
    options.envPairs.push('NODE_CHANNEL_FD=' + ipcFd);
  }

  this.spawnfile = options.file;
  this.spawnargs = options.args;

  var err = this._handle.spawn(options);

  // Run-time errors should emit an error, not throw an exception.
  if (err === uv.UV_EAGAIN ||
      err === uv.UV_EMFILE ||
      err === uv.UV_ENFILE ||
      err === uv.UV_ENOENT) {
    process.nextTick(onErrorNT, self, err);
    // There is no point in continuing when we've hit EMFILE or ENFILE
    // because we won't be able to set up the stdio file descriptors.
    // It's kind of silly that the de facto spec for ENOENT (the test suite)
    // mandates that stdio _is_ set up, even if there is no process on the
    // receiving end, but it is what it is.
    if (err !== uv.UV_ENOENT) return err;
  } else if (err) {
    // Close all opened fds on error
    for (i = 0; i &lt; stdio.length; i++) {
      const stream = stdio[i];
      if (stream.type === 'pipe') {
        stream.handle.close();
      }
    }

    this._handle.close();
    this._handle = null;
    throw errnoException(err, 'spawn');
  }

  this.pid = this._handle.pid;

  for (i = 0; i &lt; stdio.length; i++) {
    const stream = stdio[i];
    if (stream.type === 'ignore') continue;

    if (stream.ipc) {
      self._closesNeeded++;
      continue;
    }

    if (stream.handle) {
      // when i === 0 - we're dealing with stdin
      // (which is the only one writable pipe)
      stream.socket = createSocket(self.pid !== 0 ?
          stream.handle : null, i &gt; 0);

      if (i &gt; 0 &amp;&amp; self.pid !== 0) {
        self._closesNeeded++;
        stream.socket.on('close', function() {
          maybeClose(self);
        });
      }
    }
  }

  this.stdin = stdio.length &gt;= 1 &amp;&amp; stdio[0].socket !== undefined ?
      stdio[0].socket : null;
  this.stdout = stdio.length &gt;= 2 &amp;&amp; stdio[1].socket !== undefined ?
      stdio[1].socket : null;
  this.stderr = stdio.length &gt;= 3 &amp;&amp; stdio[2].socket !== undefined ?
      stdio[2].socket : null;

  this.stdio = stdio.map(function(stdio) {
    return stdio.socket === undefined ? null : stdio.socket;
  });

  // Add .send() method and start listening for IPC data
  if (ipc !== undefined) setupChannel(this, ipc);

  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.child_process.ChildProcess.prototype.unref" id="apidoc.element.mz.child_process.ChildProcess.prototype.unref">
        function <span class="apidocSignatureSpan">mz.child_process.ChildProcess.prototype.</span>unref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unref = function () {
  if (this._handle) this._handle.unref();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto" id="apidoc.module.mz.crypto">module mz.crypto</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Certificate" id="apidoc.element.mz.crypto.Certificate">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Certificate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Certificate() {
  if (!(this instanceof Certificate))
    return new Certificate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher" id="apidoc.element.mz.crypto.Cipher">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Cipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipher(cipher, password, options) {
  if (!(this instanceof Cipher))
    return new Cipher(cipher, password, options);
  this._handle = new binding.CipherBase(true);

  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv" id="apidoc.element.mz.crypto.Cipheriv">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Cipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipheriv(cipher, key, iv, options) {
  if (!(this instanceof Cipheriv))
    return new Cipheriv(cipher, key, iv, options);
  this._handle = new binding.CipherBase(true);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher" id="apidoc.element.mz.crypto.Decipher">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Decipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipher(cipher, password, options) {
  if (!(this instanceof Decipher))
    return new Decipher(cipher, password, options);

  this._handle = new binding.CipherBase(false);
  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv" id="apidoc.element.mz.crypto.Decipheriv">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Decipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipheriv(cipher, key, iv, options) {
  if (!(this instanceof Decipheriv))
    return new Decipheriv(cipher, key, iv, options);

  this._handle = new binding.CipherBase(false);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman" id="apidoc.element.mz.crypto.DiffieHellman">
        function <span class="apidocSignatureSpan">mz.crypto.</span>DiffieHellman
        <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {
  if (!(this instanceof DiffieHellman))
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);

  if (!(sizeOrKey instanceof Buffer) &amp;&amp;
      typeof sizeOrKey !== 'number' &amp;&amp;
      typeof sizeOrKey !== 'string')
    throw new TypeError('First argument should be number, string or Buffer');

  if (keyEncoding) {
    if (typeof keyEncoding !== 'string' ||
        (!Buffer.isEncoding(keyEncoding) &amp;&amp; keyEncoding !== 'buffer')) {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
  }

  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;
  genEncoding = genEncoding || exports.DEFAULT_ENCODING;

  if (typeof sizeOrKey !== 'number')
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);

  if (!generator)
    generator = DH_GENERATOR;
  else if (typeof generator !== 'number')
    generator = toBuf(generator, genEncoding);

  this._handle = new binding.DiffieHellman(sizeOrKey, generator);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellmanGroup" id="apidoc.element.mz.crypto.DiffieHellmanGroup">
        function <span class="apidocSignatureSpan">mz.crypto.</span>DiffieHellmanGroup
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this._handle = new binding.DiffieHellmanGroup(name);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hash" id="apidoc.element.mz.crypto.Hash">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Hash
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hash(algorithm, options) {
  if (!(this instanceof Hash))
    return new Hash(algorithm, options);
  this._handle = new binding.Hash(algorithm);
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac" id="apidoc.element.mz.crypto.Hmac">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Hmac
        <span class="apidocSignatureSpan">(hmac, key, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hmac(hmac, key, options) {
  if (!(this instanceof Hmac))
    return new Hmac(hmac, key, options);
  this._handle = new binding.Hmac();
  this._handle.init(hmac, toBuf(key));
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Sign" id="apidoc.element.mz.crypto.Sign">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Sign
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sign(algorithm, options) {
  if (!(this instanceof Sign))
    return new Sign(algorithm, options);
  this._handle = new binding.Sign();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Verify" id="apidoc.element.mz.crypto.Verify">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Verify
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Verify(algorithm, options) {
  if (!(this instanceof Verify))
    return new Verify(algorithm, options);

  this._handle = new binding.Verify();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto._toBuf" id="apidoc.element.mz.crypto._toBuf">
        function <span class="apidocSignatureSpan">mz.crypto.</span>_toBuf
        <span class="apidocSignatureSpan">(str, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toBuf(str, encoding) {
  if (typeof str === 'string') {
    if (encoding === 'buffer' || !encoding)
      encoding = 'utf8';
    return Buffer.from(str, encoding);
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createCipher" id="apidoc.element.mz.crypto.createCipher">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createCipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipher(cipher, password, options) {
  if (!(this instanceof Cipher))
    return new Cipher(cipher, password, options);
  this._handle = new binding.CipherBase(true);

  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createCipheriv" id="apidoc.element.mz.crypto.createCipheriv">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createCipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipheriv(cipher, key, iv, options) {
  if (!(this instanceof Cipheriv))
    return new Cipheriv(cipher, key, iv, options);
  this._handle = new binding.CipherBase(true);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createDecipher" id="apidoc.element.mz.crypto.createDecipher">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createDecipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipher(cipher, password, options) {
  if (!(this instanceof Decipher))
    return new Decipher(cipher, password, options);

  this._handle = new binding.CipherBase(false);
  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createDecipheriv" id="apidoc.element.mz.crypto.createDecipheriv">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createDecipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipheriv(cipher, key, iv, options) {
  if (!(this instanceof Decipheriv))
    return new Decipheriv(cipher, key, iv, options);

  this._handle = new binding.CipherBase(false);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createDiffieHellman" id="apidoc.element.mz.crypto.createDiffieHellman">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createDiffieHellman
        <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {
  if (!(this instanceof DiffieHellman))
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);

  if (!(sizeOrKey instanceof Buffer) &amp;&amp;
      typeof sizeOrKey !== 'number' &amp;&amp;
      typeof sizeOrKey !== 'string')
    throw new TypeError('First argument should be number, string or Buffer');

  if (keyEncoding) {
    if (typeof keyEncoding !== 'string' ||
        (!Buffer.isEncoding(keyEncoding) &amp;&amp; keyEncoding !== 'buffer')) {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
  }

  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;
  genEncoding = genEncoding || exports.DEFAULT_ENCODING;

  if (typeof sizeOrKey !== 'number')
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);

  if (!generator)
    generator = DH_GENERATOR;
  else if (typeof generator !== 'number')
    generator = toBuf(generator, genEncoding);

  this._handle = new binding.DiffieHellman(sizeOrKey, generator);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createDiffieHellmanGroup" id="apidoc.element.mz.crypto.createDiffieHellmanGroup">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createDiffieHellmanGroup
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this._handle = new binding.DiffieHellmanGroup(name);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createECDH" id="apidoc.element.mz.crypto.createECDH">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createECDH
        <span class="apidocSignatureSpan">(curve)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createECDH(curve) {
  return new ECDH(curve);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createHash" id="apidoc.element.mz.crypto.createHash">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createHash
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hash(algorithm, options) {
  if (!(this instanceof Hash))
    return new Hash(algorithm, options);
  this._handle = new binding.Hash(algorithm);
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createHmac" id="apidoc.element.mz.crypto.createHmac">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createHmac
        <span class="apidocSignatureSpan">(hmac, key, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hmac(hmac, key, options) {
  if (!(this instanceof Hmac))
    return new Hmac(hmac, key, options);
  this._handle = new binding.Hmac();
  this._handle.init(hmac, toBuf(key));
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createSign" id="apidoc.element.mz.crypto.createSign">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createSign
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sign(algorithm, options) {
  if (!(this instanceof Sign))
    return new Sign(algorithm, options);
  this._handle = new binding.Sign();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.createVerify" id="apidoc.element.mz.crypto.createVerify">
        function <span class="apidocSignatureSpan">mz.crypto.</span>createVerify
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Verify(algorithm, options) {
  if (!(this instanceof Verify))
    return new Verify(algorithm, options);

  this._handle = new binding.Verify();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getCiphers" id="apidoc.element.mz.crypto.getCiphers">
        function <span class="apidocSignatureSpan">mz.crypto.</span>getCiphers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  if (result === undefined)
    result = fn();
  return result.slice();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getCurves" id="apidoc.element.mz.crypto.getCurves">
        function <span class="apidocSignatureSpan">mz.crypto.</span>getCurves
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  if (result === undefined)
    result = fn();
  return result.slice();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman" id="apidoc.element.mz.crypto.getDiffieHellman">
        function <span class="apidocSignatureSpan">mz.crypto.</span>getDiffieHellman
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this._handle = new binding.DiffieHellmanGroup(name);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getHashes" id="apidoc.element.mz.crypto.getHashes">
        function <span class="apidocSignatureSpan">mz.crypto.</span>getHashes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  if (result === undefined)
    result = fn();
  return result.slice();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.pbkdf2" id="apidoc.element.mz.crypto.pbkdf2">
        function <span class="apidocSignatureSpan">mz.crypto.</span>pbkdf2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pbkdf2 = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.pbkdf2Sync" id="apidoc.element.mz.crypto.pbkdf2Sync">
        function <span class="apidocSignatureSpan">mz.crypto.</span>pbkdf2Sync
        <span class="apidocSignatureSpan">(password, salt, iterations, keylen, digest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pbkdf2Sync = function (password, salt, iterations, keylen, digest) {
  if (typeof digest === 'undefined') {
    digest = undefined;
    pbkdf2DeprecationWarning();
  }
  return pbkdf2(password, salt, iterations, keylen, digest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.privateDecrypt" id="apidoc.element.mz.crypto.privateDecrypt">
        function <span class="apidocSignatureSpan">mz.crypto.</span>privateDecrypt
        <span class="apidocSignatureSpan">(options, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateDecrypt = function (options, buffer) {
  var key = options.key || options;
  var passphrase = options.passphrase || null;
  var padding = options.padding || defaultPadding;
  return method(toBuf(key), buffer, padding, passphrase);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.privateEncrypt" id="apidoc.element.mz.crypto.privateEncrypt">
        function <span class="apidocSignatureSpan">mz.crypto.</span>privateEncrypt
        <span class="apidocSignatureSpan">(options, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">privateEncrypt = function (options, buffer) {
  var key = options.key || options;
  var passphrase = options.passphrase || null;
  var padding = options.padding || defaultPadding;
  return method(toBuf(key), buffer, padding, passphrase);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.prng" id="apidoc.element.mz.crypto.prng">
        function <span class="apidocSignatureSpan">mz.crypto.</span>prng
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function randomBytes() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.pseudoRandomBytes" id="apidoc.element.mz.crypto.pseudoRandomBytes">
        function <span class="apidocSignatureSpan">mz.crypto.</span>pseudoRandomBytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function randomBytes() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.publicDecrypt" id="apidoc.element.mz.crypto.publicDecrypt">
        function <span class="apidocSignatureSpan">mz.crypto.</span>publicDecrypt
        <span class="apidocSignatureSpan">(options, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicDecrypt = function (options, buffer) {
  var key = options.key || options;
  var padding = options.padding || defaultPadding;
  var passphrase = options.passphrase || null;
  return method(toBuf(key), buffer, padding, passphrase);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.publicEncrypt" id="apidoc.element.mz.crypto.publicEncrypt">
        function <span class="apidocSignatureSpan">mz.crypto.</span>publicEncrypt
        <span class="apidocSignatureSpan">(options, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publicEncrypt = function (options, buffer) {
  var key = options.key || options;
  var padding = options.padding || defaultPadding;
  var passphrase = options.passphrase || null;
  return method(toBuf(key), buffer, padding, passphrase);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.randomBytes" id="apidoc.element.mz.crypto.randomBytes">
        function <span class="apidocSignatureSpan">mz.crypto.</span>randomBytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function randomBytes() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.rng" id="apidoc.element.mz.crypto.rng">
        function <span class="apidocSignatureSpan">mz.crypto.</span>rng
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function randomBytes() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.setEngine" id="apidoc.element.mz.crypto.setEngine">
        function <span class="apidocSignatureSpan">mz.crypto.</span>setEngine
        <span class="apidocSignatureSpan">(id, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setEngine(id, flags) {
  if (typeof id !== 'string')
    throw new TypeError('"id" argument should be a string');

  if (flags &amp;&amp; typeof flags !== 'number')
    throw new TypeError('"flags" argument should be a number, if present');
  flags = flags &gt;&gt;&gt; 0;

  // Use provided engine for everything by default
  if (flags === 0)
    flags = constants.ENGINE_METHOD_ALL;

  return binding.setEngine(id, flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.timingSafeEqual" id="apidoc.element.mz.crypto.timingSafeEqual">
        function <span class="apidocSignatureSpan">mz.crypto.</span>timingSafeEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timingSafeEqual() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Certificate" id="apidoc.module.mz.crypto.Certificate">module mz.crypto.Certificate</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Certificate.Certificate" id="apidoc.element.mz.crypto.Certificate.Certificate">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Certificate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Certificate() {
  if (!(this instanceof Certificate))
    return new Certificate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Certificate.prototype" id="apidoc.module.mz.crypto.Certificate.prototype">module mz.crypto.Certificate.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Certificate.prototype.exportChallenge" id="apidoc.element.mz.crypto.Certificate.prototype.exportChallenge">
        function <span class="apidocSignatureSpan">mz.crypto.Certificate.prototype.</span>exportChallenge
        <span class="apidocSignatureSpan">(object, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportChallenge = function (object, encoding) {
  return binding.certExportChallenge(toBuf(object, encoding));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Certificate.prototype.exportPublicKey" id="apidoc.element.mz.crypto.Certificate.prototype.exportPublicKey">
        function <span class="apidocSignatureSpan">mz.crypto.Certificate.prototype.</span>exportPublicKey
        <span class="apidocSignatureSpan">(object, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportPublicKey = function (object, encoding) {
  return binding.certExportPublicKey(toBuf(object, encoding));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Certificate.prototype.verifySpkac" id="apidoc.element.mz.crypto.Certificate.prototype.verifySpkac">
        function <span class="apidocSignatureSpan">mz.crypto.Certificate.prototype.</span>verifySpkac
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifySpkac = function (object) {
  return binding.certVerifySpkac(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Cipher" id="apidoc.module.mz.crypto.Cipher">module mz.crypto.Cipher</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.Cipher" id="apidoc.element.mz.crypto.Cipher.Cipher">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Cipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipher(cipher, password, options) {
  if (!(this instanceof Cipher))
    return new Cipher(cipher, password, options);
  this._handle = new binding.CipherBase(true);

  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.super_" id="apidoc.element.mz.crypto.Cipher.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LazyTransform(options) {
  this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Cipher.prototype" id="apidoc.module.mz.crypto.Cipher.prototype">module mz.crypto.Cipher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype._flush" id="apidoc.element.mz.crypto.Cipher.prototype._flush">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  try {
    this.push(this._handle.final());
  } catch (e) {
    callback(e);
    return;
  }
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype._transform" id="apidoc.element.mz.crypto.Cipher.prototype._transform">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this.push(this._handle.update(chunk, encoding));
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype.final" id="apidoc.element.mz.crypto.Cipher.prototype.final">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>final
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">final = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.final();

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.end(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype.getAuthTag" id="apidoc.element.mz.crypto.Cipher.prototype.getAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>getAuthTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAuthTag = function () {
  return this._handle.getAuthTag();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype.setAAD" id="apidoc.element.mz.crypto.Cipher.prototype.setAAD">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>setAAD
        <span class="apidocSignatureSpan">(aadbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAAD = function (aadbuf) {
  this._handle.setAAD(aadbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype.setAuthTag" id="apidoc.element.mz.crypto.Cipher.prototype.setAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>setAuthTag
        <span class="apidocSignatureSpan">(tagbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAuthTag = function (tagbuf) {
  this._handle.setAuthTag(tagbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype.setAutoPadding" id="apidoc.element.mz.crypto.Cipher.prototype.setAutoPadding">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>setAutoPadding
        <span class="apidocSignatureSpan">(ap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAutoPadding = function (ap) {
  this._handle.setAutoPadding(ap);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipher.prototype.update" id="apidoc.element.mz.crypto.Cipher.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Cipher.prototype.</span>update
        <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, inputEncoding, outputEncoding) {
  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;

  var ret = this._handle.update(data, inputEncoding);

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.write(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Cipheriv" id="apidoc.module.mz.crypto.Cipheriv">module mz.crypto.Cipheriv</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.Cipheriv" id="apidoc.element.mz.crypto.Cipheriv.Cipheriv">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Cipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cipheriv(cipher, key, iv, options) {
  if (!(this instanceof Cipheriv))
    return new Cipheriv(cipher, key, iv, options);
  this._handle = new binding.CipherBase(true);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.super_" id="apidoc.element.mz.crypto.Cipheriv.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LazyTransform(options) {
  this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Cipheriv.prototype" id="apidoc.module.mz.crypto.Cipheriv.prototype">module mz.crypto.Cipheriv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype._flush" id="apidoc.element.mz.crypto.Cipheriv.prototype._flush">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  try {
    this.push(this._handle.final());
  } catch (e) {
    callback(e);
    return;
  }
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype._transform" id="apidoc.element.mz.crypto.Cipheriv.prototype._transform">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this.push(this._handle.update(chunk, encoding));
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype.final" id="apidoc.element.mz.crypto.Cipheriv.prototype.final">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>final
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">final = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.final();

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.end(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype.getAuthTag" id="apidoc.element.mz.crypto.Cipheriv.prototype.getAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>getAuthTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAuthTag = function () {
  return this._handle.getAuthTag();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype.setAAD" id="apidoc.element.mz.crypto.Cipheriv.prototype.setAAD">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>setAAD
        <span class="apidocSignatureSpan">(aadbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAAD = function (aadbuf) {
  this._handle.setAAD(aadbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype.setAuthTag" id="apidoc.element.mz.crypto.Cipheriv.prototype.setAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>setAuthTag
        <span class="apidocSignatureSpan">(tagbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAuthTag = function (tagbuf) {
  this._handle.setAuthTag(tagbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype.setAutoPadding" id="apidoc.element.mz.crypto.Cipheriv.prototype.setAutoPadding">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>setAutoPadding
        <span class="apidocSignatureSpan">(ap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAutoPadding = function (ap) {
  this._handle.setAutoPadding(ap);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Cipheriv.prototype.update" id="apidoc.element.mz.crypto.Cipheriv.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Cipheriv.prototype.</span>update
        <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, inputEncoding, outputEncoding) {
  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;

  var ret = this._handle.update(data, inputEncoding);

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.write(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Decipher" id="apidoc.module.mz.crypto.Decipher">module mz.crypto.Decipher</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.Decipher" id="apidoc.element.mz.crypto.Decipher.Decipher">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Decipher
        <span class="apidocSignatureSpan">(cipher, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipher(cipher, password, options) {
  if (!(this instanceof Decipher))
    return new Decipher(cipher, password, options);

  this._handle = new binding.CipherBase(false);
  this._handle.init(cipher, toBuf(password));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.super_" id="apidoc.element.mz.crypto.Decipher.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LazyTransform(options) {
  this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Decipher.prototype" id="apidoc.module.mz.crypto.Decipher.prototype">module mz.crypto.Decipher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype._flush" id="apidoc.element.mz.crypto.Decipher.prototype._flush">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  try {
    this.push(this._handle.final());
  } catch (e) {
    callback(e);
    return;
  }
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype._transform" id="apidoc.element.mz.crypto.Decipher.prototype._transform">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this.push(this._handle.update(chunk, encoding));
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype.final" id="apidoc.element.mz.crypto.Decipher.prototype.final">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>final
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">final = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.final();

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.end(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype.finaltol" id="apidoc.element.mz.crypto.Decipher.prototype.finaltol">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>finaltol
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finaltol = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.final();

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.end(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype.getAuthTag" id="apidoc.element.mz.crypto.Decipher.prototype.getAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>getAuthTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAuthTag = function () {
  return this._handle.getAuthTag();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype.setAAD" id="apidoc.element.mz.crypto.Decipher.prototype.setAAD">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>setAAD
        <span class="apidocSignatureSpan">(aadbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAAD = function (aadbuf) {
  this._handle.setAAD(aadbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype.setAuthTag" id="apidoc.element.mz.crypto.Decipher.prototype.setAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>setAuthTag
        <span class="apidocSignatureSpan">(tagbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAuthTag = function (tagbuf) {
  this._handle.setAuthTag(tagbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype.setAutoPadding" id="apidoc.element.mz.crypto.Decipher.prototype.setAutoPadding">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>setAutoPadding
        <span class="apidocSignatureSpan">(ap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAutoPadding = function (ap) {
  this._handle.setAutoPadding(ap);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipher.prototype.update" id="apidoc.element.mz.crypto.Decipher.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Decipher.prototype.</span>update
        <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, inputEncoding, outputEncoding) {
  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;

  var ret = this._handle.update(data, inputEncoding);

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.write(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Decipheriv" id="apidoc.module.mz.crypto.Decipheriv">module mz.crypto.Decipheriv</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.Decipheriv" id="apidoc.element.mz.crypto.Decipheriv.Decipheriv">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Decipheriv
        <span class="apidocSignatureSpan">(cipher, key, iv, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decipheriv(cipher, key, iv, options) {
  if (!(this instanceof Decipheriv))
    return new Decipheriv(cipher, key, iv, options);

  this._handle = new binding.CipherBase(false);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;

  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.super_" id="apidoc.element.mz.crypto.Decipheriv.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LazyTransform(options) {
  this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Decipheriv.prototype" id="apidoc.module.mz.crypto.Decipheriv.prototype">module mz.crypto.Decipheriv.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype._flush" id="apidoc.element.mz.crypto.Decipheriv.prototype._flush">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  try {
    this.push(this._handle.final());
  } catch (e) {
    callback(e);
    return;
  }
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype._transform" id="apidoc.element.mz.crypto.Decipheriv.prototype._transform">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this.push(this._handle.update(chunk, encoding));
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype.final" id="apidoc.element.mz.crypto.Decipheriv.prototype.final">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>final
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">final = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.final();

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.end(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype.finaltol" id="apidoc.element.mz.crypto.Decipheriv.prototype.finaltol">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>finaltol
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finaltol = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.final();

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.end(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype.getAuthTag" id="apidoc.element.mz.crypto.Decipheriv.prototype.getAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>getAuthTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAuthTag = function () {
  return this._handle.getAuthTag();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype.setAAD" id="apidoc.element.mz.crypto.Decipheriv.prototype.setAAD">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>setAAD
        <span class="apidocSignatureSpan">(aadbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAAD = function (aadbuf) {
  this._handle.setAAD(aadbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype.setAuthTag" id="apidoc.element.mz.crypto.Decipheriv.prototype.setAuthTag">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>setAuthTag
        <span class="apidocSignatureSpan">(tagbuf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAuthTag = function (tagbuf) {
  this._handle.setAuthTag(tagbuf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype.setAutoPadding" id="apidoc.element.mz.crypto.Decipheriv.prototype.setAutoPadding">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>setAutoPadding
        <span class="apidocSignatureSpan">(ap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAutoPadding = function (ap) {
  this._handle.setAutoPadding(ap);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Decipheriv.prototype.update" id="apidoc.element.mz.crypto.Decipheriv.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Decipheriv.prototype.</span>update
        <span class="apidocSignatureSpan">(data, inputEncoding, outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, inputEncoding, outputEncoding) {
  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;

  var ret = this._handle.update(data, inputEncoding);

  if (outputEncoding &amp;&amp; outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.write(ret);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.DiffieHellman" id="apidoc.module.mz.crypto.DiffieHellman">module mz.crypto.DiffieHellman</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.DiffieHellman" id="apidoc.element.mz.crypto.DiffieHellman.DiffieHellman">
        function <span class="apidocSignatureSpan">mz.crypto.</span>DiffieHellman
        <span class="apidocSignatureSpan">(sizeOrKey, keyEncoding, generator, genEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {
  if (!(this instanceof DiffieHellman))
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);

  if (!(sizeOrKey instanceof Buffer) &amp;&amp;
      typeof sizeOrKey !== 'number' &amp;&amp;
      typeof sizeOrKey !== 'string')
    throw new TypeError('First argument should be number, string or Buffer');

  if (keyEncoding) {
    if (typeof keyEncoding !== 'string' ||
        (!Buffer.isEncoding(keyEncoding) &amp;&amp; keyEncoding !== 'buffer')) {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
  }

  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;
  genEncoding = genEncoding || exports.DEFAULT_ENCODING;

  if (typeof sizeOrKey !== 'number')
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);

  if (!generator)
    generator = DH_GENERATOR;
  else if (typeof generator !== 'number')
    generator = toBuf(generator, genEncoding);

  this._handle = new binding.DiffieHellman(sizeOrKey, generator);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.DiffieHellman.prototype" id="apidoc.module.mz.crypto.DiffieHellman.prototype">module mz.crypto.DiffieHellman.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.computeSecret" id="apidoc.element.mz.crypto.DiffieHellman.prototype.computeSecret">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>computeSecret
        <span class="apidocSignatureSpan">(key, inEnc, outEnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhComputeSecret(key, inEnc, outEnc) {
  inEnc = inEnc || exports.DEFAULT_ENCODING;
  outEnc = outEnc || exports.DEFAULT_ENCODING;
  var ret = this._handle.computeSecret(toBuf(key, inEnc));
  if (outEnc &amp;&amp; outEnc !== 'buffer')
    ret = ret.toString(outEnc);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.generateKeys" id="apidoc.element.mz.crypto.DiffieHellman.prototype.generateKeys">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>generateKeys
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGenerateKeys(encoding) {
  var keys = this._handle.generateKeys();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    keys = keys.toString(encoding);
  return keys;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getGenerator" id="apidoc.element.mz.crypto.DiffieHellman.prototype.getGenerator">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getGenerator
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetGenerator(encoding) {
  var generator = this._handle.getGenerator();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    generator = generator.toString(encoding);
  return generator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getPrime" id="apidoc.element.mz.crypto.DiffieHellman.prototype.getPrime">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getPrime
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetPrime(encoding) {
  var prime = this._handle.getPrime();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    prime = prime.toString(encoding);
  return prime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getPrivateKey" id="apidoc.element.mz.crypto.DiffieHellman.prototype.getPrivateKey">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getPrivateKey
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetPrivateKey(encoding) {
  var key = this._handle.getPrivateKey();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    key = key.toString(encoding);
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.getPublicKey" id="apidoc.element.mz.crypto.DiffieHellman.prototype.getPublicKey">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>getPublicKey
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetPublicKey(encoding) {
  var key = this._handle.getPublicKey();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    key = key.toString(encoding);
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.setPrivateKey" id="apidoc.element.mz.crypto.DiffieHellman.prototype.setPrivateKey">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>setPrivateKey
        <span class="apidocSignatureSpan">(key, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPrivateKey = function (key, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.setPrivateKey(toBuf(key, encoding));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.DiffieHellman.prototype.setPublicKey" id="apidoc.element.mz.crypto.DiffieHellman.prototype.setPublicKey">
        function <span class="apidocSignatureSpan">mz.crypto.DiffieHellman.prototype.</span>setPublicKey
        <span class="apidocSignatureSpan">(key, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPublicKey = function (key, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.setPublicKey(toBuf(key, encoding));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Hash" id="apidoc.module.mz.crypto.Hash">module mz.crypto.Hash</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Hash.Hash" id="apidoc.element.mz.crypto.Hash.Hash">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Hash
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hash(algorithm, options) {
  if (!(this instanceof Hash))
    return new Hash(algorithm, options);
  this._handle = new binding.Hash(algorithm);
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hash.super_" id="apidoc.element.mz.crypto.Hash.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Hash.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LazyTransform(options) {
  this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Hash.prototype" id="apidoc.module.mz.crypto.Hash.prototype">module mz.crypto.Hash.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Hash.prototype._flush" id="apidoc.element.mz.crypto.Hash.prototype._flush">
        function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  this.push(this._handle.digest());
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hash.prototype._transform" id="apidoc.element.mz.crypto.Hash.prototype._transform">
        function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this._handle.update(chunk, encoding);
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hash.prototype.digest" id="apidoc.element.mz.crypto.Hash.prototype.digest">
        function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>digest
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">digest = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  return this._handle.digest(outputEncoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hash.prototype.update" id="apidoc.element.mz.crypto.Hash.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Hash.prototype.</span>update
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.update(data, encoding);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Hmac" id="apidoc.module.mz.crypto.Hmac">module mz.crypto.Hmac</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac.Hmac" id="apidoc.element.mz.crypto.Hmac.Hmac">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Hmac
        <span class="apidocSignatureSpan">(hmac, key, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Hmac(hmac, key, options) {
  if (!(this instanceof Hmac))
    return new Hmac(hmac, key, options);
  this._handle = new binding.Hmac();
  this._handle.init(hmac, toBuf(key));
  LazyTransform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac.super_" id="apidoc.element.mz.crypto.Hmac.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Hmac.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LazyTransform(options) {
  this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Hmac.prototype" id="apidoc.module.mz.crypto.Hmac.prototype">module mz.crypto.Hmac.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac.prototype._flush" id="apidoc.element.mz.crypto.Hmac.prototype._flush">
        function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  this.push(this._handle.digest());
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac.prototype._transform" id="apidoc.element.mz.crypto.Hmac.prototype._transform">
        function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  this._handle.update(chunk, encoding);
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac.prototype.digest" id="apidoc.element.mz.crypto.Hmac.prototype.digest">
        function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>digest
        <span class="apidocSignatureSpan">(outputEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">digest = function (outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  return this._handle.digest(outputEncoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Hmac.prototype.update" id="apidoc.element.mz.crypto.Hmac.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Hmac.prototype.</span>update
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.update(data, encoding);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Sign" id="apidoc.module.mz.crypto.Sign">module mz.crypto.Sign</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Sign.Sign" id="apidoc.element.mz.crypto.Sign.Sign">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Sign
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sign(algorithm, options) {
  if (!(this instanceof Sign))
    return new Sign(algorithm, options);
  this._handle = new binding.Sign();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Sign.super_" id="apidoc.element.mz.crypto.Sign.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Sign.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &amp;&amp;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Sign.prototype" id="apidoc.module.mz.crypto.Sign.prototype">module mz.crypto.Sign.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Sign.prototype._write" id="apidoc.element.mz.crypto.Sign.prototype._write">
        function <span class="apidocSignatureSpan">mz.crypto.Sign.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, callback) {
  this._handle.update(chunk, encoding);
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Sign.prototype.sign" id="apidoc.element.mz.crypto.Sign.prototype.sign">
        function <span class="apidocSignatureSpan">mz.crypto.Sign.prototype.</span>sign
        <span class="apidocSignatureSpan">(options, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (options, encoding) {
  if (!options)
    throw new Error('No key provided to sign');

  var key = options.key || options;
  var passphrase = options.passphrase || null;
  var ret = this._handle.sign(toBuf(key), null, passphrase);

  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    ret = ret.toString(encoding);

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Sign.prototype.update" id="apidoc.element.mz.crypto.Sign.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Sign.prototype.</span>update
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.update(data, encoding);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Verify" id="apidoc.module.mz.crypto.Verify">module mz.crypto.Verify</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Verify.Verify" id="apidoc.element.mz.crypto.Verify.Verify">
        function <span class="apidocSignatureSpan">mz.crypto.</span>Verify
        <span class="apidocSignatureSpan">(algorithm, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Verify(algorithm, options) {
  if (!(this instanceof Verify))
    return new Verify(algorithm, options);

  this._handle = new binding.Verify();
  this._handle.init(algorithm);

  stream.Writable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Verify.super_" id="apidoc.element.mz.crypto.Verify.super_">
        function <span class="apidocSignatureSpan">mz.crypto.Verify.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &amp;&amp;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.Verify.prototype" id="apidoc.module.mz.crypto.Verify.prototype">module mz.crypto.Verify.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.Verify.prototype._write" id="apidoc.element.mz.crypto.Verify.prototype._write">
        function <span class="apidocSignatureSpan">mz.crypto.Verify.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, callback) {
  this._handle.update(chunk, encoding);
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Verify.prototype.update" id="apidoc.element.mz.crypto.Verify.prototype.update">
        function <span class="apidocSignatureSpan">mz.crypto.Verify.prototype.</span>update
        <span class="apidocSignatureSpan">(data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (data, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.update(data, encoding);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.Verify.prototype.verify" id="apidoc.element.mz.crypto.Verify.prototype.verify">
        function <span class="apidocSignatureSpan">mz.crypto.Verify.prototype.</span>verify
        <span class="apidocSignatureSpan">(object, signature, sigEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (object, signature, sigEncoding) {
  sigEncoding = sigEncoding || exports.DEFAULT_ENCODING;
  return this._handle.verify(toBuf(object), toBuf(signature, sigEncoding));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.getDiffieHellman" id="apidoc.module.mz.crypto.getDiffieHellman">module mz.crypto.getDiffieHellman</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman.getDiffieHellman" id="apidoc.element.mz.crypto.getDiffieHellman.getDiffieHellman">
        function <span class="apidocSignatureSpan">mz.crypto.</span>getDiffieHellman
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this._handle = new binding.DiffieHellmanGroup(name);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.crypto.getDiffieHellman.prototype" id="apidoc.module.mz.crypto.getDiffieHellman.prototype">module mz.crypto.getDiffieHellman.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.computeSecret" id="apidoc.element.mz.crypto.getDiffieHellman.prototype.computeSecret">
        function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>computeSecret
        <span class="apidocSignatureSpan">(key, inEnc, outEnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhComputeSecret(key, inEnc, outEnc) {
  inEnc = inEnc || exports.DEFAULT_ENCODING;
  outEnc = outEnc || exports.DEFAULT_ENCODING;
  var ret = this._handle.computeSecret(toBuf(key, inEnc));
  if (outEnc &amp;&amp; outEnc !== 'buffer')
    ret = ret.toString(outEnc);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.generateKeys" id="apidoc.element.mz.crypto.getDiffieHellman.prototype.generateKeys">
        function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>generateKeys
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGenerateKeys(encoding) {
  var keys = this._handle.generateKeys();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    keys = keys.toString(encoding);
  return keys;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getGenerator" id="apidoc.element.mz.crypto.getDiffieHellman.prototype.getGenerator">
        function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getGenerator
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetGenerator(encoding) {
  var generator = this._handle.getGenerator();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    generator = generator.toString(encoding);
  return generator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getPrime" id="apidoc.element.mz.crypto.getDiffieHellman.prototype.getPrime">
        function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getPrime
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetPrime(encoding) {
  var prime = this._handle.getPrime();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    prime = prime.toString(encoding);
  return prime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getPrivateKey" id="apidoc.element.mz.crypto.getDiffieHellman.prototype.getPrivateKey">
        function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getPrivateKey
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetPrivateKey(encoding) {
  var key = this._handle.getPrivateKey();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    key = key.toString(encoding);
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.crypto.getDiffieHellman.prototype.getPublicKey" id="apidoc.element.mz.crypto.getDiffieHellman.prototype.getPublicKey">
        function <span class="apidocSignatureSpan">mz.crypto.getDiffieHellman.prototype.</span>getPublicKey
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dhGetPublicKey(encoding) {
  var key = this._handle.getPublicKey();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding &amp;&amp; encoding !== 'buffer')
    key = key.toString(encoding);
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.dns" id="apidoc.module.mz.dns">module mz.dns</a></h1>


    <h2>
        <a href="#apidoc.element.mz.dns.getServers" id="apidoc.element.mz.dns.getServers">
        function <span class="apidocSignatureSpan">mz.dns.</span>getServers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getServers = function () {
  return cares.getServers();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.lookup" id="apidoc.element.mz.dns.lookup">
        function <span class="apidocSignatureSpan">mz.dns.</span>lookup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookup() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.lookupService" id="apidoc.element.mz.dns.lookupService">
        function <span class="apidocSignatureSpan">mz.dns.</span>lookupService
        <span class="apidocSignatureSpan">(host, port, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupService = function (host, port, callback) {
  if (arguments.length !== 3)
    throw new Error('Invalid arguments');

  if (isIP(host) === 0)
    throw new TypeError('"host" argument needs to be a valid IP address');

  if (!isLegalPort(port))
    throw new TypeError(`"port" should be &gt;= 0 and &lt; 65536, got "${port}"`);

  if (typeof callback !== 'function')
    throw new TypeError('"callback" argument must be a function');

  port = +port;
  callback = makeAsync(callback);

  var req = new GetNameInfoReqWrap();
  req.callback = callback;
  req.host = host;
  req.port = port;
  req.oncomplete = onlookupservice;

  var err = cares.getnameinfo(req, host, port);
  if (err) throw errnoException(err, 'getnameinfo', host);

  callback.immediately = true;
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolve" id="apidoc.element.mz.dns.resolve">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolve4" id="apidoc.element.mz.dns.resolve4">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolve4
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolve6" id="apidoc.element.mz.dns.resolve6">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolve6
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolveCname" id="apidoc.element.mz.dns.resolveCname">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolveCname
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolveMx" id="apidoc.element.mz.dns.resolveMx">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolveMx
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolveNaptr" id="apidoc.element.mz.dns.resolveNaptr">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolveNaptr
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(name, callback) {
  if (typeof name !== 'string') {
    throw new Error('"name" argument must be a string');
  } else if (typeof callback !== 'function') {
    throw new Error('"callback" argument must be a function');
  }

  callback = makeAsync(callback);
  var req = new QueryReqWrap();
  req.bindingName = bindingName;
  req.callback = callback;
  req.hostname = name;
  req.oncomplete = onresolve;
  var err = binding(req, name);
  if (err) throw errnoException(err, bindingName);
  callback.immediately = true;
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolveNs" id="apidoc.element.mz.dns.resolveNs">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolveNs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolvePtr" id="apidoc.element.mz.dns.resolvePtr">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolvePtr
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(name, callback) {
  if (typeof name !== 'string') {
    throw new Error('"name" argument must be a string');
  } else if (typeof callback !== 'function') {
    throw new Error('"callback" argument must be a function');
  }

  callback = makeAsync(callback);
  var req = new QueryReqWrap();
  req.bindingName = bindingName;
  req.callback = callback;
  req.hostname = name;
  req.oncomplete = onresolve;
  var err = binding(req, name);
  if (err) throw errnoException(err, bindingName);
  callback.immediately = true;
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolveSoa" id="apidoc.element.mz.dns.resolveSoa">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolveSoa
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(name, callback) {
  if (typeof name !== 'string') {
    throw new Error('"name" argument must be a string');
  } else if (typeof callback !== 'function') {
    throw new Error('"callback" argument must be a function');
  }

  callback = makeAsync(callback);
  var req = new QueryReqWrap();
  req.bindingName = bindingName;
  req.callback = callback;
  req.hostname = name;
  req.oncomplete = onresolve;
  var err = binding(req, name);
  if (err) throw errnoException(err, bindingName);
  callback.immediately = true;
  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolveSrv" id="apidoc.element.mz.dns.resolveSrv">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolveSrv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.resolveTxt" id="apidoc.element.mz.dns.resolveTxt">
        function <span class="apidocSignatureSpan">mz.dns.</span>resolveTxt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.reverse" id="apidoc.element.mz.dns.reverse">
        function <span class="apidocSignatureSpan">mz.dns.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.dns.setServers" id="apidoc.element.mz.dns.setServers">
        function <span class="apidocSignatureSpan">mz.dns.</span>setServers
        <span class="apidocSignatureSpan">(servers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setServers = function (servers) {
  // cache the original servers because in the event of an error setting the
  // servers cares won't have any servers available for resolution
  const orig = cares.getServers();
  const newSet = [];

  servers.forEach((serv) =&gt; {
    var ipVersion = isIP(serv);
    if (ipVersion !== 0)
      return newSet.push([ipVersion, serv]);

    const match = serv.match(/\[(.*)\](?::\d+)?/);
    // we have an IPv6 in brackets
    if (match) {
      ipVersion = isIP(match[1]);
      if (ipVersion !== 0)
        return newSet.push([ipVersion, match[1]]);
    }

    const s = serv.split(/:\d+$/)[0];
    ipVersion = isIP(s);

    if (ipVersion !== 0)
      return newSet.push([ipVersion, s]);

    throw new Error(`IP address is not properly formatted: ${serv}`);
  });

  const errorNumber = cares.setServers(newSet);

  if (errorNumber !== 0) {
    // reset the servers to the old servers, because ares probably unset them
    cares.setServers(orig.join(','));

    var err = cares.strerror(errorNumber);
    throw new Error(`c-ares failed to set servers: "${err}" [${servers}]`);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.fs" id="apidoc.module.mz.fs">module mz.fs</a></h1>


    <h2>
        <a href="#apidoc.element.mz.fs.FileReadStream" id="apidoc.element.mz.fs.FileReadStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>FileReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  // a little bit bigger buffer and water marks by default
  options = Object.create(options);
  if (options.highWaterMark === undefined)
    options.highWaterMark = 64 * 1024;

  Readable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'r' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  this.bytesRead = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== 'number') {
      throw new TypeError('"end" option must be a Number');
    }

    if (this.start &gt; this.end) {
      throw new Error('"start" option must be &lt;= "end" option');
    }

    this.pos = this.start;
  }

  if (typeof this.fd !== 'number')
    this.open();

  this.on('end', function() {
    if (this.autoClose) {
      this.destroy();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.FileWriteStream" id="apidoc.element.mz.fs.FileWriteStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>FileWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (!(this instanceof WriteStream))
    return new WriteStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  options = Object.create(options);

  Writable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'w' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
  this.pos = undefined;
  this.bytesWritten = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.start &lt; 0) {
      throw new Error('"start" must be &gt;= zero');
    }

    this.pos = this.start;
  }

  if (options.encoding)
    this.setDefaultEncoding(options.encoding);

  if (typeof this.fd !== 'number')
    this.open();

  // dispose on finish.
  this.once('finish', function() {
    if (this.autoClose) {
      this.close();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream" id="apidoc.element.mz.fs.ReadStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>ReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  // a little bit bigger buffer and water marks by default
  options = Object.create(options);
  if (options.highWaterMark === undefined)
    options.highWaterMark = 64 * 1024;

  Readable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'r' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  this.bytesRead = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== 'number') {
      throw new TypeError('"end" option must be a Number');
    }

    if (this.start &gt; this.end) {
      throw new Error('"start" option must be &lt;= "end" option');
    }

    this.pos = this.start;
  }

  if (typeof this.fd !== 'number')
    this.open();

  this.on('end', function() {
    if (this.autoClose) {
      this.destroy();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats" id="apidoc.element.mz.fs.Stats">
        function <span class="apidocSignatureSpan">mz.fs.</span>Stats
        <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = new Date(atim_msec);
  this.mtime = new Date(mtim_msec);
  this.ctime = new Date(ctim_msec);
  this.birthtime = new Date(birthtim_msec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream" id="apidoc.element.mz.fs.WriteStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>WriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (!(this instanceof WriteStream))
    return new WriteStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  options = Object.create(options);

  Writable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'w' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
  this.pos = undefined;
  this.bytesWritten = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.start &lt; 0) {
      throw new Error('"start" must be &gt;= zero');
    }

    this.pos = this.start;
  }

  if (options.encoding)
    this.setDefaultEncoding(options.encoding);

  if (typeof this.fd !== 'number')
    this.open();

  // dispose on finish.
  this.once('finish', function() {
    if (this.autoClose) {
      this.close();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs._toUnixTimestamp" id="apidoc.element.mz.fs._toUnixTimestamp">
        function <span class="apidocSignatureSpan">mz.fs.</span>_toUnixTimestamp
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toUnixTimestamp(time) {
  if (typeof time === 'string' &amp;&amp; +time == time) {
    return +time;
  }
  if (typeof time === 'number') {
    if (!Number.isFinite(time) || time &lt; 0) {
      return Date.now() / 1000;
    }
    return time;
  }
  if (util.isDate(time)) {
    // convert to 123.456 UNIX timestamp
    return time.getTime() / 1000;
  }
  throw new Error('Cannot parse time: ' + time);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.access" id="apidoc.element.mz.fs.access">
        function <span class="apidocSignatureSpan">mz.fs.</span>access
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">access = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.accessSync" id="apidoc.element.mz.fs.accessSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>accessSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accessSync = function (path, mode) {
  nullCheck(path);

  if (mode === undefined)
    mode = fs.F_OK;
  else
    mode = mode | 0;

  binding.access(pathModule._makeLong(path), mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.appendFile" id="apidoc.element.mz.fs.appendFile">
        function <span class="apidocSignatureSpan">mz.fs.</span>appendFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFile = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.appendFileSync" id="apidoc.element.mz.fs.appendFileSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>appendFileSync
        <span class="apidocSignatureSpan">(path, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFileSync = function (path, data, options) {
  if (!options) {
    options = { encoding: 'utf8', mode: 0o666, flag: 'a' };
  } else if (typeof options === 'string') {
    options = { encoding: options, mode: 0o666, flag: 'a' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  }

  if (!options.flag)
    options = util._extend({ flag: 'a' }, options);

  // force append behavior when using a supplied file descriptor
  if (isFd(path))
    options.flag = 'a';

  fs.writeFileSync(path, data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.chmod" id="apidoc.element.mz.fs.chmod">
        function <span class="apidocSignatureSpan">mz.fs.</span>chmod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.chmodSync" id="apidoc.element.mz.fs.chmodSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>chmodSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmodSync = function (path, mode) {
  nullCheck(path);
  return binding.chmod(pathModule._makeLong(path), modeNum(mode));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.chown" id="apidoc.element.mz.fs.chown">
        function <span class="apidocSignatureSpan">mz.fs.</span>chown
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chown = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.chownSync" id="apidoc.element.mz.fs.chownSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>chownSync
        <span class="apidocSignatureSpan">(path, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chownSync = function (path, uid, gid) {
  nullCheck(path);
  return binding.chown(pathModule._makeLong(path), uid, gid);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.close" id="apidoc.element.mz.fs.close">
        function <span class="apidocSignatureSpan">mz.fs.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.closeSync" id="apidoc.element.mz.fs.closeSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>closeSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeSync = function (fd) {
  return binding.close(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.createReadStream" id="apidoc.element.mz.fs.createReadStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>createReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReadStream = function (path, options) {
  return new ReadStream(path, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.createWriteStream" id="apidoc.element.mz.fs.createWriteStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>createWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriteStream = function (path, options) {
  return new WriteStream(path, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.exists" id="apidoc.element.mz.fs.exists">
        function <span class="apidocSignatureSpan">mz.fs.</span>exists
        <span class="apidocSignatureSpan">(filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (filename, callback) {
  // callback
  if (typeof callback === 'function') {
    return fs.stat(filename, function (err) {
      callback(null, !err);
    })
  }
  // or promise
  return new Promise(function (resolve) {
    fs.stat(filename, function (err) {
      resolve(!err)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Then prefix the relevant `require()`s with `mz/`:

```js
var fs = require('mz/fs')

fs.<span class="apidocCodeKeywordSpan">exists</span>(__filename).then(function (exists) {
  if (exists) // do something
})
```

With ES2017, this will allow you to use async functions cleanly with node's core API:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.existsSync" id="apidoc.element.mz.fs.existsSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>existsSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsSync = function (path) {
  try {
    nullCheck(path);
    binding.stat(pathModule._makeLong(path), statValues);
    return true;
  } catch (e) {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fchmod" id="apidoc.element.mz.fs.fchmod">
        function <span class="apidocSignatureSpan">mz.fs.</span>fchmod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmod = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fchmodSync" id="apidoc.element.mz.fs.fchmodSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>fchmodSync
        <span class="apidocSignatureSpan">(fd, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmodSync = function (fd, mode) {
  return binding.fchmod(fd, modeNum(mode));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fchown" id="apidoc.element.mz.fs.fchown">
        function <span class="apidocSignatureSpan">mz.fs.</span>fchown
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchown = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fchownSync" id="apidoc.element.mz.fs.fchownSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>fchownSync
        <span class="apidocSignatureSpan">(fd, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchownSync = function (fd, uid, gid) {
  return binding.fchown(fd, uid, gid);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fdatasync" id="apidoc.element.mz.fs.fdatasync">
        function <span class="apidocSignatureSpan">mz.fs.</span>fdatasync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fdatasync = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fdatasyncSync" id="apidoc.element.mz.fs.fdatasyncSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>fdatasyncSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fdatasyncSync = function (fd) {
  return binding.fdatasync(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fstat" id="apidoc.element.mz.fs.fstat">
        function <span class="apidocSignatureSpan">mz.fs.</span>fstat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstat = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fstatSync" id="apidoc.element.mz.fs.fstatSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>fstatSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstatSync = function (fd) {
  binding.fstat(fd, statValues);
  return statsFromValues();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fsync" id="apidoc.element.mz.fs.fsync">
        function <span class="apidocSignatureSpan">mz.fs.</span>fsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsync = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.fsyncSync" id="apidoc.element.mz.fs.fsyncSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>fsyncSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsyncSync = function (fd) {
  return binding.fsync(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ftruncate" id="apidoc.element.mz.fs.ftruncate">
        function <span class="apidocSignatureSpan">mz.fs.</span>ftruncate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ftruncate = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ftruncateSync" id="apidoc.element.mz.fs.ftruncateSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>ftruncateSync
        <span class="apidocSignatureSpan">(fd, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ftruncateSync = function (fd, len) {
  if (len === undefined) {
    len = 0;
  }
  return binding.ftruncate(fd, len);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.futimes" id="apidoc.element.mz.fs.futimes">
        function <span class="apidocSignatureSpan">mz.fs.</span>futimes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimes = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.futimesSync" id="apidoc.element.mz.fs.futimesSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>futimesSync
        <span class="apidocSignatureSpan">(fd, atime, mtime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimesSync = function (fd, atime, mtime) {
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.futimes(fd, atime, mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.link" id="apidoc.element.mz.fs.link">
        function <span class="apidocSignatureSpan">mz.fs.</span>link
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.linkSync" id="apidoc.element.mz.fs.linkSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>linkSync
        <span class="apidocSignatureSpan">(existingPath, newPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linkSync = function (existingPath, newPath) {
  nullCheck(existingPath);
  nullCheck(newPath);
  return binding.link(pathModule._makeLong(existingPath),
                      pathModule._makeLong(newPath));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.lstat" id="apidoc.element.mz.fs.lstat">
        function <span class="apidocSignatureSpan">mz.fs.</span>lstat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstat = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.lstatSync" id="apidoc.element.mz.fs.lstatSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>lstatSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstatSync = function (path) {
  nullCheck(path);
  binding.lstat(pathModule._makeLong(path), statValues);
  return statsFromValues();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.mkdir" id="apidoc.element.mz.fs.mkdir">
        function <span class="apidocSignatureSpan">mz.fs.</span>mkdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.mkdirSync" id="apidoc.element.mz.fs.mkdirSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>mkdirSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirSync = function (path, mode) {
  nullCheck(path);
  return binding.mkdir(pathModule._makeLong(path),
                       modeNum(mode, 0o777));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.mkdtemp" id="apidoc.element.mz.fs.mkdtemp">
        function <span class="apidocSignatureSpan">mz.fs.</span>mkdtemp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdtemp = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.mkdtempSync" id="apidoc.element.mz.fs.mkdtempSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>mkdtempSync
        <span class="apidocSignatureSpan">(prefix, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdtempSync = function (prefix, options) {
  if (!prefix || typeof prefix !== 'string')
    throw new TypeError('filename prefix is required');

  options = options || {};
  if (typeof options === 'string')
    options = {encoding: options};
  if (typeof options !== 'object')
    throw new TypeError('"options" must be a string or an object');
  nullCheck(prefix);

  return binding.mkdtemp(prefix + 'XXXXXX', options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.open" id="apidoc.element.mz.fs.open">
        function <span class="apidocSignatureSpan">mz.fs.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.openSync" id="apidoc.element.mz.fs.openSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>openSync
        <span class="apidocSignatureSpan">(path, flags, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openSync = function (path, flags, mode) {
  mode = modeNum(mode, 0o666);
  nullCheck(path);
  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.read" id="apidoc.element.mz.fs.read">
        function <span class="apidocSignatureSpan">mz.fs.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.readFile" id="apidoc.element.mz.fs.readFile">
        function <span class="apidocSignatureSpan">mz.fs.</span>readFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.readFileSync" id="apidoc.element.mz.fs.readFileSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>readFileSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileSync = function (path, options) {
  if (!options) {
    options = { encoding: null, flag: 'r' };
  } else if (typeof options === 'string') {
    options = { encoding: options, flag: 'r' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  }

  var encoding = options.encoding;
  assertEncoding(encoding);

  var flag = options.flag || 'r';
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, 0o666);

  var st = tryStatSync(fd, isUserFd);
  var size = st.isFile() ? st.size : 0;
  var pos = 0;
  var buffer; // single buffer with file data
  var buffers; // list for when size is unknown

  if (size === 0) {
    buffers = [];
  } else {
    buffer = tryCreateBuffer(size, fd, isUserFd);
  }

  var bytesRead;

  if (size !== 0) {
    do {
      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);
      pos += bytesRead;
    } while (bytesRead !== 0 &amp;&amp; pos &lt; size);
  } else {
    do {
      // the kernel lies about many files.
      // Go ahead and try to read some bytes.
      buffer = Buffer.allocUnsafe(8192);
      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);
      if (bytesRead !== 0) {
        buffers.push(buffer.slice(0, bytesRead));
      }
      pos += bytesRead;
    } while (bytesRead !== 0);
  }

  if (!isUserFd)
    fs.closeSync(fd);

  if (size === 0) {
    // data was collected into the buffers list.
    buffer = Buffer.concat(buffers, pos);
  } else if (pos &lt; size) {
    buffer = buffer.slice(0, pos);
  }

  if (encoding) buffer = buffer.toString(encoding);
  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.readSync" id="apidoc.element.mz.fs.readSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>readSync
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readSync = function (fd, buffer, offset, length, position) {
  var legacy = false;
  var encoding;

  if (!(buffer instanceof Buffer)) {
    // legacy string interface (fd, length, position, encoding, callback)
    readSyncWarned = printDeprecation('fs.readSync\'s legacy String interface' +
                                      'is deprecated. Use the Buffer API as ' +
                                      'mentioned in the documentation instead.',
                                      readSyncWarned);
    legacy = true;
    encoding = arguments[3];

    assertEncoding(encoding);

    position = arguments[2];
    length = arguments[1];
    buffer = Buffer.allocUnsafe(length);

    offset = 0;
  }

  if (length === 0) {
    if (legacy) {
      return ['', 0];
    } else {
      return 0;
    }
  }

  var r = binding.read(fd, buffer, offset, length, position);
  if (!legacy) {
    return r;
  }

  var str = (r &gt; 0) ? buffer.toString(encoding, 0, r) : '';
  return [str, r];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.readdir" id="apidoc.element.mz.fs.readdir">
        function <span class="apidocSignatureSpan">mz.fs.</span>readdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdir = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.readdirSync" id="apidoc.element.mz.fs.readdirSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>readdirSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdirSync = function (path, options) {
  options = options || {};
  if (typeof options === 'string')
    options = {encoding: options};
  if (typeof options !== 'object')
    throw new TypeError('"options" must be a string or an object');
  nullCheck(path);
  return binding.readdir(pathModule._makeLong(path), options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.readlink" id="apidoc.element.mz.fs.readlink">
        function <span class="apidocSignatureSpan">mz.fs.</span>readlink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlink = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.readlinkSync" id="apidoc.element.mz.fs.readlinkSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>readlinkSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlinkSync = function (path, options) {
  options = options || {};
  if (typeof options === 'string')
    options = {encoding: options};
  if (typeof options !== 'object')
    throw new TypeError('"options" must be a string or an object');
  nullCheck(path);
  return binding.readlink(pathModule._makeLong(path), options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.realpath" id="apidoc.element.mz.fs.realpath">
        function <span class="apidocSignatureSpan">mz.fs.</span>realpath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function realpath() {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.realpathSync" id="apidoc.element.mz.fs.realpathSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>realpathSync
        <span class="apidocSignatureSpan">(p, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function realpathSync(p, options) {
  if (!options)
    options = {};
  else if (typeof options === 'string')
    options = {encoding: options};
  else if (typeof options !== 'object')
    throw new TypeError('"options" must be a string or an object');
  nullCheck(p);

  p = p.toString('utf8');
  p = pathModule.resolve(p);

  const seenLinks = {};
  const knownHard = {};
  const cache = options[realpathCacheKey];
  const original = p;

  const maybeCachedResult = cache &amp;&amp; cache.get(p);
  if (maybeCachedResult) {
    return maybeCachedResult;
  }

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows &amp;&amp; !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos &lt; p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache &amp;&amp; cache.get(base) === base)) {
      continue;
    }

    var resolvedLink;
    const maybeCachedResolved = cache &amp;&amp; cache.get(base);
    if (maybeCachedResolved) {
      resolvedLink = maybeCachedResolved;
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache.set(base, base);
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      let linkTarget = null;
      let id;
      if (!isWindows) {
        id = `${stat.dev.toString(32)}:${stat.ino.toString(32)}`;
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);

      if (cache) cache.set(base, resolvedLink);
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache.set(original, p);
  return encodeRealpathResult(p, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.rename" id="apidoc.element.mz.fs.rename">
        function <span class="apidocSignatureSpan">mz.fs.</span>rename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.renameSync" id="apidoc.element.mz.fs.renameSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>renameSync
        <span class="apidocSignatureSpan">(oldPath, newPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renameSync = function (oldPath, newPath) {
  nullCheck(oldPath);
  nullCheck(newPath);
  return binding.rename(pathModule._makeLong(oldPath),
                        pathModule._makeLong(newPath));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.rmdir" id="apidoc.element.mz.fs.rmdir">
        function <span class="apidocSignatureSpan">mz.fs.</span>rmdir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdir = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.rmdirSync" id="apidoc.element.mz.fs.rmdirSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>rmdirSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdirSync = function (path) {
  nullCheck(path);
  return binding.rmdir(pathModule._makeLong(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.stat" id="apidoc.element.mz.fs.stat">
        function <span class="apidocSignatureSpan">mz.fs.</span>stat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.statSync" id="apidoc.element.mz.fs.statSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>statSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statSync = function (path) {
  nullCheck(path);
  binding.stat(pathModule._makeLong(path), statValues);
  return statsFromValues();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.symlink" id="apidoc.element.mz.fs.symlink">
        function <span class="apidocSignatureSpan">mz.fs.</span>symlink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlink = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.symlinkSync" id="apidoc.element.mz.fs.symlinkSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>symlinkSync
        <span class="apidocSignatureSpan">(target, path, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlinkSync = function (target, path, type) {
  type = (typeof type === 'string' ? type : null);

  nullCheck(target);
  nullCheck(path);

  return binding.symlink(preprocessSymlinkDestination(target, type, path),
                         pathModule._makeLong(path),
                         type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.truncate" id="apidoc.element.mz.fs.truncate">
        function <span class="apidocSignatureSpan">mz.fs.</span>truncate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncate = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.truncateSync" id="apidoc.element.mz.fs.truncateSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>truncateSync
        <span class="apidocSignatureSpan">(path, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncateSync = function (path, len) {
  if (typeof path === 'number') {
    // legacy
    return fs.ftruncateSync(path, len);
  }
  if (len === undefined) {
    len = 0;
  }
  // allow error to be thrown, but still close fd.
  var fd = fs.openSync(path, 'r+');
  var ret;

  try {
    ret = fs.ftruncateSync(fd, len);
  } finally {
    fs.closeSync(fd);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.unlink" id="apidoc.element.mz.fs.unlink">
        function <span class="apidocSignatureSpan">mz.fs.</span>unlink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.unlinkSync" id="apidoc.element.mz.fs.unlinkSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>unlinkSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlinkSync = function (path) {
  nullCheck(path);
  return binding.unlink(pathModule._makeLong(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.unwatchFile" id="apidoc.element.mz.fs.unwatchFile">
        function <span class="apidocSignatureSpan">mz.fs.</span>unwatchFile
        <span class="apidocSignatureSpan">(filename, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwatchFile = function (filename, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat = statWatchers.get(filename);

  if (stat === undefined) return;

  if (typeof listener === 'function') {
    stat.removeListener('change', listener);
  } else {
    stat.removeAllListeners('change');
  }

  if (stat.listenerCount('change') === 0) {
    stat.stop();
    statWatchers.delete(filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.utimes" id="apidoc.element.mz.fs.utimes">
        function <span class="apidocSignatureSpan">mz.fs.</span>utimes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimes = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.utimesSync" id="apidoc.element.mz.fs.utimesSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>utimesSync
        <span class="apidocSignatureSpan">(path, atime, mtime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimesSync = function (path, atime, mtime) {
  nullCheck(path);
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.utimes(pathModule._makeLong(path), atime, mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.watch" id="apidoc.element.mz.fs.watch">
        function <span class="apidocSignatureSpan">mz.fs.</span>watch
        <span class="apidocSignatureSpan">(filename, options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (filename, options, listener) {
  nullCheck(filename);

  options = options || {};
  if (typeof options === 'function') {
    listener = options;
    options = {};
  } else if (typeof options === 'string') {
    options = {encoding: options};
  }
  if (typeof options !== 'object')
    throw new TypeError('"options" must be a string or an object');

  if (options.persistent === undefined) options.persistent = true;
  if (options.recursive === undefined) options.recursive = false;

  const watcher = new FSWatcher();
  watcher.start(filename,
                options.persistent,
                options.recursive,
                options.encoding);

  if (listener) {
    watcher.addListener('change', listener);
  }

  return watcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.watchFile" id="apidoc.element.mz.fs.watchFile">
        function <span class="apidocSignatureSpan">mz.fs.</span>watchFile
        <span class="apidocSignatureSpan">(filename, options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watchFile = function (filename, options, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat;

  var defaults = {
    // Poll interval in milliseconds. 5007 is what libev used to use. It's
    // a little on the slow side but let's stick with it for now to keep
    // behavioral changes to a minimum.
    interval: 5007,
    persistent: true
  };

  if (options !== null &amp;&amp; typeof options === 'object') {
    options = util._extend(defaults, options);
  } else {
    listener = options;
    options = defaults;
  }

  if (typeof listener !== 'function') {
    throw new Error('"watchFile()" requires a listener function');
  }

  stat = statWatchers.get(filename);

  if (stat === undefined) {
    stat = new StatWatcher();
    stat.start(filename, options.persistent, options.interval);
    statWatchers.set(filename, stat);
  }

  stat.addListener('change', listener);
  return stat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.write" id="apidoc.element.mz.fs.write">
        function <span class="apidocSignatureSpan">mz.fs.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.writeFile" id="apidoc.element.mz.fs.writeFile">
        function <span class="apidocSignatureSpan">mz.fs.</span>writeFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.writeFileSync" id="apidoc.element.mz.fs.writeFileSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>writeFileSync
        <span class="apidocSignatureSpan">(path, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFileSync = function (path, data, options) {
  if (!options) {
    options = { encoding: 'utf8', mode: 0o666, flag: 'w' };
  } else if (typeof options === 'string') {
    options = { encoding: options, mode: 0o666, flag: 'w' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  }

  assertEncoding(options.encoding);

  var flag = options.flag || 'w';
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);

  if (!(data instanceof Buffer)) {
    data = Buffer.from('' + data, options.encoding || 'utf8');
  }
  var offset = 0;
  var length = data.length;
  var position = /a/.test(flag) ? null : 0;
  try {
    while (length &gt; 0) {
      var written = fs.writeSync(fd, data, offset, length, position);
      offset += written;
      length -= written;
      if (position !== null) {
        position += written;
      }
    }
  } finally {
    if (!isUserFd) fs.closeSync(fd);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.writeSync" id="apidoc.element.mz.fs.writeSync">
        function <span class="apidocSignatureSpan">mz.fs.</span>writeSync
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeSync = function (fd, buffer, offset, length, position) {
  if (buffer instanceof Buffer) {
    if (position === undefined)
      position = null;
    return binding.writeBuffer(fd, buffer, offset, length, position);
  }
  if (typeof buffer !== 'string')
    buffer += '';
  if (offset === undefined)
    offset = null;
  return binding.writeString(fd, buffer, offset, length, position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.fs.ReadStream" id="apidoc.module.mz.fs.ReadStream">module mz.fs.ReadStream</a></h1>


    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream.ReadStream" id="apidoc.element.mz.fs.ReadStream.ReadStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>ReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  // a little bit bigger buffer and water marks by default
  options = Object.create(options);
  if (options.highWaterMark === undefined)
    options.highWaterMark = 64 * 1024;

  Readable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'r' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  this.bytesRead = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== 'number') {
      throw new TypeError('"end" option must be a Number');
    }

    if (this.start &gt; this.end) {
      throw new Error('"start" option must be &lt;= "end" option');
    }

    this.pos = this.start;
  }

  if (typeof this.fd !== 'number')
    this.open();

  this.on('end', function() {
    if (this.autoClose) {
      this.destroy();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream.super_" id="apidoc.element.mz.fs.ReadStream.super_">
        function <span class="apidocSignatureSpan">mz.fs.ReadStream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &amp;&amp; typeof options.read === 'function')
    this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.fs.ReadStream.prototype" id="apidoc.module.mz.fs.ReadStream.prototype">module mz.fs.ReadStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream.prototype._read" id="apidoc.element.mz.fs.ReadStream.prototype._read">
        function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>_read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (n) {
  if (typeof this.fd !== 'number')
    return this.once('open', function() {
      this._read(n);
    });

  if (this.destroyed)
    return;

  if (!pool || pool.length - pool.used &lt; kMinPoolSpace) {
    // discard the old pool.
    allocNewPool(this._readableState.highWaterMark);
  }

  // Grab another reference to the pool in the case that while we're
  // in the thread pool another read() finishes up the pool, and
  // allocates a new one.
  var thisPool = pool;
  var toRead = Math.min(pool.length - pool.used, n);
  var start = pool.used;

  if (this.pos !== undefined)
    toRead = Math.min(this.end - this.pos + 1, toRead);

  // already read everything we were supposed to read!
  // treat as EOF.
  if (toRead &lt;= 0)
    return this.push(null);

  // the actual read.
  var self = this;
  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);

  // move the pool positions, and internal position for reading.
  if (this.pos !== undefined)
    this.pos += toRead;
  pool.used += toRead;

  function onread(er, bytesRead) {
    if (er) {
      if (self.autoClose) {
        self.destroy();
      }
      self.emit('error', er);
    } else {
      var b = null;
      if (bytesRead &gt; 0) {
        self.bytesRead += bytesRead;
        b = thisPool.slice(start, start + bytesRead);
      }

      self.push(b);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream.prototype.close" id="apidoc.element.mz.fs.ReadStream.prototype.close">
        function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  var self = this;
  if (cb)
    this.once('close', cb);
  if (this.closed || typeof this.fd !== 'number') {
    if (typeof this.fd !== 'number') {
      this.once('open', close);
      return;
    }
    return process.nextTick(() =&gt; this.emit('close'));
  }
  this.closed = true;
  close();

  function close(fd) {
    fs.close(fd || self.fd, function(er) {
      if (er)
        self.emit('error', er);
      else
        self.emit('close');
    });
    self.fd = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream.prototype.destroy" id="apidoc.element.mz.fs.ReadStream.prototype.destroy">
        function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  if (this.destroyed)
    return;
  this.destroyed = true;
  this.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.ReadStream.prototype.open" id="apidoc.element.mz.fs.ReadStream.prototype.open">
        function <span class="apidocSignatureSpan">mz.fs.ReadStream.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
  var self = this;
  fs.open(this.path, this.flags, this.mode, function(er, fd) {
    if (er) {
      if (self.autoClose) {
        self.destroy();
      }
      self.emit('error', er);
      return;
    }

    self.fd = fd;
    self.emit('open', fd);
    // start the flow of data.
    self.read();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.fs.Stats" id="apidoc.module.mz.fs.Stats">module mz.fs.Stats</a></h1>


    <h2>
        <a href="#apidoc.element.mz.fs.Stats.Stats" id="apidoc.element.mz.fs.Stats.Stats">
        function <span class="apidocSignatureSpan">mz.fs.</span>Stats
        <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = new Date(atim_msec);
  this.mtime = new Date(mtim_msec);
  this.ctime = new Date(ctim_msec);
  this.birthtime = new Date(birthtim_msec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.fs.Stats.prototype" id="apidoc.module.mz.fs.Stats.prototype">module mz.fs.Stats.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype._checkModeProperty" id="apidoc.element.mz.fs.Stats.prototype._checkModeProperty">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>_checkModeProperty
        <span class="apidocSignatureSpan">(property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkModeProperty = function (property) {
  return ((this.mode &amp; constants.S_IFMT) === property);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype.isBlockDevice" id="apidoc.element.mz.fs.Stats.prototype.isBlockDevice">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isBlockDevice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBlockDevice = function () {
  return this._checkModeProperty(constants.S_IFBLK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype.isCharacterDevice" id="apidoc.element.mz.fs.Stats.prototype.isCharacterDevice">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isCharacterDevice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCharacterDevice = function () {
  return this._checkModeProperty(constants.S_IFCHR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype.isDirectory" id="apidoc.element.mz.fs.Stats.prototype.isDirectory">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isDirectory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectory = function () {
  return this._checkModeProperty(constants.S_IFDIR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype.isFIFO" id="apidoc.element.mz.fs.Stats.prototype.isFIFO">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isFIFO
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFIFO = function () {
  return this._checkModeProperty(constants.S_IFIFO);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype.isFile" id="apidoc.element.mz.fs.Stats.prototype.isFile">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFile = function () {
  return this._checkModeProperty(constants.S_IFREG);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype.isSocket" id="apidoc.element.mz.fs.Stats.prototype.isSocket">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSocket = function () {
  return this._checkModeProperty(constants.S_IFSOCK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.Stats.prototype.isSymbolicLink" id="apidoc.element.mz.fs.Stats.prototype.isSymbolicLink">
        function <span class="apidocSignatureSpan">mz.fs.Stats.prototype.</span>isSymbolicLink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSymbolicLink = function () {
  return this._checkModeProperty(constants.S_IFLNK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.fs.WriteStream" id="apidoc.module.mz.fs.WriteStream">module mz.fs.WriteStream</a></h1>


    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.WriteStream" id="apidoc.element.mz.fs.WriteStream.WriteStream">
        function <span class="apidocSignatureSpan">mz.fs.</span>WriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (!(this instanceof WriteStream))
    return new WriteStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('"options" argument must be a string or an object');

  options = Object.create(options);

  Writable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'w' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
  this.pos = undefined;
  this.bytesWritten = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('"start" option must be a Number');
    }
    if (this.start &lt; 0) {
      throw new Error('"start" must be &gt;= zero');
    }

    this.pos = this.start;
  }

  if (options.encoding)
    this.setDefaultEncoding(options.encoding);

  if (typeof this.fd !== 'number')
    this.open();

  // dispose on finish.
  this.once('finish', function() {
    if (this.autoClose) {
      this.close();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.super_" id="apidoc.element.mz.fs.WriteStream.super_">
        function <span class="apidocSignatureSpan">mz.fs.WriteStream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &amp;&amp;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.fs.WriteStream.prototype" id="apidoc.module.mz.fs.WriteStream.prototype">module mz.fs.WriteStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.prototype._write" id="apidoc.element.mz.fs.WriteStream.prototype._write">
        function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>_write
        <span class="apidocSignatureSpan">(data, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (data, encoding, cb) {
  if (!(data instanceof Buffer))
    return this.emit('error', new Error('Invalid data'));

  if (typeof this.fd !== 'number')
    return this.once('open', function() {
      this._write(data, encoding, cb);
    });

  var self = this;
  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
    if (er) {
      if (self.autoClose) {
        self.destroy();
      }
      return cb(er);
    }
    self.bytesWritten += bytes;
    cb();
  });

  if (this.pos !== undefined)
    this.pos += data.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.prototype._writev" id="apidoc.element.mz.fs.WriteStream.prototype._writev">
        function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>_writev
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_writev = function (data, cb) {
  if (typeof this.fd !== 'number')
    return this.once('open', function() {
      this._writev(data, cb);
    });

  const self = this;
  const len = data.length;
  const chunks = new Array(len);
  var size = 0;

  for (var i = 0; i &lt; len; i++) {
    var chunk = data[i].chunk;

    chunks[i] = chunk;
    size += chunk.length;
  }

  writev(this.fd, chunks, this.pos, function(er, bytes) {
    if (er) {
      self.destroy();
      return cb(er);
    }
    self.bytesWritten += bytes;
    cb();
  });

  if (this.pos !== undefined)
    this.pos += size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.prototype.close" id="apidoc.element.mz.fs.WriteStream.prototype.close">
        function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  var self = this;
  if (cb)
    this.once('close', cb);
  if (this.closed || typeof this.fd !== 'number') {
    if (typeof this.fd !== 'number') {
      this.once('open', close);
      return;
    }
    return process.nextTick(() =&gt; this.emit('close'));
  }
  this.closed = true;
  close();

  function close(fd) {
    fs.close(fd || self.fd, function(er) {
      if (er)
        self.emit('error', er);
      else
        self.emit('close');
    });
    self.fd = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.prototype.destroy" id="apidoc.element.mz.fs.WriteStream.prototype.destroy">
        function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  if (this.destroyed)
    return;
  this.destroyed = true;
  this.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.prototype.destroySoon" id="apidoc.element.mz.fs.WriteStream.prototype.destroySoon">
        function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>destroySoon
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroySoon = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null &amp;&amp; chunk !== undefined)
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending &amp;&amp; !state.finished)
    endWritable(this, state, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.fs.WriteStream.prototype.open" id="apidoc.element.mz.fs.WriteStream.prototype.open">
        function <span class="apidocSignatureSpan">mz.fs.WriteStream.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
  fs.open(this.path, this.flags, this.mode, function(er, fd) {
    if (er) {
      if (this.autoClose) {
        this.destroy();
      }
      this.emit('error', er);
      return;
    }

    this.fd = fd;
    this.emit('open', fd);
  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.readline" id="apidoc.module.mz.readline">module mz.readline</a></h1>


    <h2>
        <a href="#apidoc.element.mz.readline.Interface" id="apidoc.element.mz.readline.Interface">
        function <span class="apidocSignatureSpan">mz.readline.</span>Interface
        <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InterfaceAsPromised(input, output, completer, terminal) {
  if (arguments.length === 1) {
    var options = input

    if (typeof options.completer === 'function') {
      options = objectAssign({}, options, {
        completer: wrapCompleter(options.completer)
      })
    }

    Interface.call(this, options)
  } else {
    if (typeof completer === 'function') {
      completer = wrapCompleter(completer)
    }

    Interface.call(this, input, output, completer, terminal)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.clearLine" id="apidoc.element.mz.readline.clearLine">
        function <span class="apidocSignatureSpan">mz.readline.</span>clearLine
        <span class="apidocSignatureSpan">(stream, dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearLine(stream, dir) {
  if (stream === null || stream === undefined)
    return;

  if (dir &lt; 0) {
    // to the beginning
    stream.write('\x1b[1K');
  } else if (dir &gt; 0) {
    // to the end
    stream.write('\x1b[0K');
  } else {
    // entire line
    stream.write('\x1b[2K');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.clearScreenDown" id="apidoc.element.mz.readline.clearScreenDown">
        function <span class="apidocSignatureSpan">mz.readline.</span>clearScreenDown
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearScreenDown(stream) {
  if (stream === null || stream === undefined)
    return;

  stream.write('\x1b[0J');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.codePointAt" id="apidoc.element.mz.readline.codePointAt">
        function <span class="apidocSignatureSpan">mz.readline.</span>codePointAt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.createInterface" id="apidoc.element.mz.readline.createInterface">
        function <span class="apidocSignatureSpan">mz.readline.</span>createInterface
        <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createInterface = function (input, output, completer, terminal) {
  if (arguments.length === 1) {
    return new InterfaceAsPromised(input)
  }

  return new InterfaceAsPromised(input, output, completer, terminal)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.cursorTo" id="apidoc.element.mz.readline.cursorTo">
        function <span class="apidocSignatureSpan">mz.readline.</span>cursorTo
        <span class="apidocSignatureSpan">(stream, x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cursorTo(stream, x, y) {
  if (stream === null || stream === undefined)
    return;

  if (typeof x !== 'number' &amp;&amp; typeof y !== 'number')
    return;

  if (typeof x !== 'number')
    throw new Error('Can\'t set cursor row without also setting it\'s column');

  if (typeof y !== 'number') {
    stream.write('\x1b[' + (x + 1) + 'G');
  } else {
    stream.write('\x1b[' + (y + 1) + ';' + (x + 1) + 'H');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.emitKeypressEvents" id="apidoc.element.mz.readline.emitKeypressEvents">
        function <span class="apidocSignatureSpan">mz.readline.</span>emitKeypressEvents
        <span class="apidocSignatureSpan">(stream, iface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitKeypressEvents(stream, iface) {
  if (stream[KEYPRESS_DECODER]) return;
  var StringDecoder = require('string_decoder').StringDecoder; // lazy load
  stream[KEYPRESS_DECODER] = new StringDecoder('utf8');

  stream[ESCAPE_DECODER] = emitKeys(stream);
  stream[ESCAPE_DECODER].next();

  const escapeCodeTimeout = () =&gt; stream[ESCAPE_DECODER].next('');
  let timeoutId;

  function onData(b) {
    if (stream.listenerCount('keypress') &gt; 0) {
      var r = stream[KEYPRESS_DECODER].write(b);
      if (r) {
        clearTimeout(timeoutId);

        if (iface) {
          iface._sawKeyPress = r.length === 1;
        }

        for (var i = 0; i &lt; r.length; i++) {
          if (r[i] === '\t' &amp;&amp; typeof r[i + 1] === 'string' &amp;&amp; iface) {
            iface.isCompletionEnabled = false;
          }

          try {
            stream[ESCAPE_DECODER].next(r[i]);
            // Escape letter at the tail position
            if (r[i] === '\x1b' &amp;&amp; i + 1 === r.length) {
              timeoutId = setTimeout(escapeCodeTimeout, ESCAPE_CODE_TIMEOUT);
            }
          } catch (err) {
            // if the generator throws (it could happen in the `keypress`
            // event), we need to restart it.
            stream[ESCAPE_DECODER] = emitKeys(stream);
            stream[ESCAPE_DECODER].next();
            throw err;
          } finally {
            if (iface) {
              iface.isCompletionEnabled = true;
            }
          }
        }
      }
    } else {
      // Nobody's watching anyway
      stream.removeListener('data', onData);
      stream.on('newListener', onNewListener);
    }
  }

  function onNewListener(event) {
    if (event === 'keypress') {
      stream.on('data', onData);
      stream.removeListener('newListener', onNewListener);
    }
  }

  if (stream.listenerCount('keypress') &gt; 0) {
    stream.on('data', onData);
  } else {
    stream.on('newListener', onNewListener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.getStringWidth" id="apidoc.element.mz.readline.getStringWidth">
        function <span class="apidocSignatureSpan">mz.readline.</span>getStringWidth
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.isFullWidthCodePoint" id="apidoc.element.mz.readline.isFullWidthCodePoint">
        function <span class="apidocSignatureSpan">mz.readline.</span>isFullWidthCodePoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.moveCursor" id="apidoc.element.mz.readline.moveCursor">
        function <span class="apidocSignatureSpan">mz.readline.</span>moveCursor
        <span class="apidocSignatureSpan">(stream, dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveCursor(stream, dx, dy) {
  if (stream === null || stream === undefined)
    return;

  if (dx &lt; 0) {
    stream.write('\x1b[' + (-dx) + 'D');
  } else if (dx &gt; 0) {
    stream.write('\x1b[' + dx + 'C');
  }

  if (dy &lt; 0) {
    stream.write('\x1b[' + (-dy) + 'A');
  } else if (dy &gt; 0) {
    stream.write('\x1b[' + dy + 'B');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.readline.stripVTControlCharacters" id="apidoc.element.mz.readline.stripVTControlCharacters">
        function <span class="apidocSignatureSpan">mz.readline.</span>stripVTControlCharacters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.readline.Interface" id="apidoc.module.mz.readline.Interface">module mz.readline.Interface</a></h1>


    <h2>
        <a href="#apidoc.element.mz.readline.Interface.Interface" id="apidoc.element.mz.readline.Interface.Interface">
        function <span class="apidocSignatureSpan">mz.readline.</span>Interface
        <span class="apidocSignatureSpan">(input, output, completer, terminal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InterfaceAsPromised(input, output, completer, terminal) {
  if (arguments.length === 1) {
    var options = input

    if (typeof options.completer === 'function') {
      options = objectAssign({}, options, {
        completer: wrapCompleter(options.completer)
      })
    }

    Interface.call(this, options)
  } else {
    if (typeof completer === 'function') {
      completer = wrapCompleter(completer)
    }

    Interface.call(this, input, output, completer, terminal)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.readline.Interface.prototype" id="apidoc.module.mz.readline.Interface.prototype">module mz.readline.Interface.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.readline.Interface.prototype.question" id="apidoc.element.mz.readline.Interface.prototype.question">
        function <span class="apidocSignatureSpan">mz.readline.Interface.prototype.</span>question
        <span class="apidocSignatureSpan">(question, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">question = function (question, callback) {
  if (typeof callback === 'function') {
    return Interface.prototype.question.call(this, question, callback)
  }

  var self = this
  return new Promise(function (resolve) {
    Interface.prototype.question.call(self, question, resolve)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib" id="apidoc.module.mz.zlib">module mz.zlib</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate" id="apidoc.element.mz.zlib.Deflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Deflate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.DeflateRaw" id="apidoc.element.mz.zlib.DeflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>DeflateRaw
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Gunzip" id="apidoc.element.mz.zlib.Gunzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Gunzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Gzip" id="apidoc.element.mz.zlib.Gzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Gzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Inflate" id="apidoc.element.mz.zlib.Inflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Inflate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.InflateRaw" id="apidoc.element.mz.zlib.InflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>InflateRaw
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Unzip" id="apidoc.element.mz.zlib.Unzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Unzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib" id="apidoc.element.mz.zlib.Zlib">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Zlib
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.createDeflate" id="apidoc.element.mz.zlib.createDeflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>createDeflate
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDeflate = function (o) {
  return new Deflate(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.createDeflateRaw" id="apidoc.element.mz.zlib.createDeflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>createDeflateRaw
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDeflateRaw = function (o) {
  return new DeflateRaw(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.createGunzip" id="apidoc.element.mz.zlib.createGunzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>createGunzip
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createGunzip = function (o) {
  return new Gunzip(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.createGzip" id="apidoc.element.mz.zlib.createGzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>createGzip
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createGzip = function (o) {
  return new Gzip(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.createInflate" id="apidoc.element.mz.zlib.createInflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>createInflate
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createInflate = function (o) {
  return new Inflate(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.createInflateRaw" id="apidoc.element.mz.zlib.createInflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>createInflateRaw
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createInflateRaw = function (o) {
  return new InflateRaw(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.createUnzip" id="apidoc.element.mz.zlib.createUnzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>createUnzip
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUnzip = function (o) {
  return new Unzip(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.deflate" id="apidoc.element.mz.zlib.deflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>deflate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deflate = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.deflateRaw" id="apidoc.element.mz.zlib.deflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>deflateRaw
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deflateRaw = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.deflateRawSync" id="apidoc.element.mz.zlib.deflateRawSync">
        function <span class="apidocSignatureSpan">mz.zlib.</span>deflateRawSync
        <span class="apidocSignatureSpan">(buffer, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.deflateSync" id="apidoc.element.mz.zlib.deflateSync">
        function <span class="apidocSignatureSpan">mz.zlib.</span>deflateSync
        <span class="apidocSignatureSpan">(buffer, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deflateSync = function (buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.gunzip" id="apidoc.element.mz.zlib.gunzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>gunzip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gunzip = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.gunzipSync" id="apidoc.element.mz.zlib.gunzipSync">
        function <span class="apidocSignatureSpan">mz.zlib.</span>gunzipSync
        <span class="apidocSignatureSpan">(buffer, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gunzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.gzip" id="apidoc.element.mz.zlib.gzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>gzip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gzip = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.gzipSync" id="apidoc.element.mz.zlib.gzipSync">
        function <span class="apidocSignatureSpan">mz.zlib.</span>gzipSync
        <span class="apidocSignatureSpan">(buffer, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.inflate" id="apidoc.element.mz.zlib.inflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>inflate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inflate = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.inflateRaw" id="apidoc.element.mz.zlib.inflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>inflateRaw
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inflateRaw = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.inflateRawSync" id="apidoc.element.mz.zlib.inflateRawSync">
        function <span class="apidocSignatureSpan">mz.zlib.</span>inflateRawSync
        <span class="apidocSignatureSpan">(buffer, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.inflateSync" id="apidoc.element.mz.zlib.inflateSync">
        function <span class="apidocSignatureSpan">mz.zlib.</span>inflateSync
        <span class="apidocSignatureSpan">(buffer, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inflateSync = function (buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.unzip" id="apidoc.element.mz.zlib.unzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>unzip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unzip = function () {
var self = this
var len = arguments.length
var lastType = typeof arguments[len - 1]
if (lastType === "function") return $$__fn__$$.apply(self, arguments)
var args = new Array(len + 1)
for (var i = 0; i &lt; len; ++i) args[i] = arguments[i]
var lastIndex = i
return new Promise(function (resolve, reject) {
args[lastIndex] = createCallback(resolve, reject)
$$__fn__$$.apply(self, args)
})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.unzipSync" id="apidoc.element.mz.zlib.unzipSync">
        function <span class="apidocSignatureSpan">mz.zlib.</span>unzipSync
        <span class="apidocSignatureSpan">(buffer, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unzipSync = function (buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Deflate" id="apidoc.module.mz.zlib.Deflate">module mz.zlib.Deflate</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.Deflate" id="apidoc.element.mz.zlib.Deflate.Deflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Deflate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_" id="apidoc.element.mz.zlib.Deflate.super_">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.</span>super_
        <span class="apidocSignatureSpan">(opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ?
    opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize &lt; exports.Z_MIN_CHUNK ||
        opts.chunkSize &gt; exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS ||
        opts.windowBits &gt; exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level &lt; exports.Z_MIN_LEVEL ||
        opts.level &gt; exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL ||
        opts.memLevel &gt; exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &amp;&amp;
        opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
        opts.strategy != exports.Z_RLE &amp;&amp;
        opts.strategy != exports.Z_FIXED &amp;&amp;
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: () =&gt; { return !this._handle; },
    configurable: true,
    enumerable: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Deflate.super_.prototype" id="apidoc.module.mz.zlib.Deflate.super_.prototype">module mz.zlib.Deflate.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_.prototype._flush" id="apidoc.element.mz.zlib.Deflate.super_.prototype._flush">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  this._transform(Buffer.alloc(0), '', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_.prototype._processChunk" id="apidoc.element.mz.zlib.Deflate.super_.prototype._processChunk">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>_processChunk
        <span class="apidocSignatureSpan">(chunk, flushFlag, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processChunk = function (chunk, flushFlag, cb) {
  var availInBefore = chunk &amp;&amp; chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function(er) {
      error = er;
    });

    assert(this._handle, 'zlib binding closed');
    do {
      var res = this._handle.writeSync(flushFlag,
                                       chunk, // in
                                       inOff, // in_off
                                       availInBefore, // in_len
                                       this._buffer, // out
                                       this._offset, //out_off
                                       availOutBefore); // out_len
    } while (!this._hadError &amp;&amp; callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    if (nread &gt;= kMaxLength) {
      _close(this);
      throw new RangeError(kRangeErrorMessage);
    }

    var buf = Buffer.concat(buffers, nread);
    _close(this);

    return buf;
  }

  assert(this._handle, 'zlib binding closed');
  var req = this._handle.write(flushFlag,
                               chunk, // in
                               inOff, // in_off
                               availInBefore, // in_len
                               this._buffer, // out
                               this._offset, //out_off
                               availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }

    if (self._hadError)
      return;

    var have = availOutBefore - availOutAfter;
    assert(have &gt;= 0, 'have should not go down');

    if (have &gt; 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset &gt;= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      if (!async)
        return true;

      var newReq = self._handle.write(flushFlag,
                                      chunk,
                                      inOff,
                                      availInBefore,
                                      self._buffer,
                                      self._offset,
                                      self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async)
      return false;

    // finished with the chunk.
    cb();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_.prototype._transform" id="apidoc.element.mz.zlib.Deflate.super_.prototype._transform">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending &amp;&amp; (!chunk || ws.length === chunk.length);

  if (chunk !== null &amp;&amp; !(chunk instanceof Buffer))
    return cb(new Error('invalid input'));

  if (!this._handle)
    return cb(new Error('zlib binding closed'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = this._finishFlushFlag;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length &gt;= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  this._processChunk(chunk, flushFlag, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_.prototype.close" id="apidoc.element.mz.zlib.Deflate.super_.prototype.close">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  _close(this, callback);
  process.nextTick(emitCloseNT, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_.prototype.flush" id="apidoc.element.mz.zlib.Deflate.super_.prototype.flush">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>flush
        <span class="apidocSignatureSpan">(kind, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (kind, callback) {
  var ws = this._writableState;

  if (typeof kind === 'function' || (kind === undefined &amp;&amp; !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', () =&gt; this.flush(kind, callback));
    }
  } else {
    this._flushFlag = kind;
    this.write(Buffer.alloc(0), '', callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_.prototype.params" id="apidoc.element.mz.zlib.Deflate.super_.prototype.params">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>params
        <span class="apidocSignatureSpan">(level, strategy, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">params = function (level, strategy, callback) {
  if (level &lt; exports.Z_MIN_LEVEL ||
      level &gt; exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED &amp;&amp;
      strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
      strategy != exports.Z_RLE &amp;&amp;
      strategy != exports.Z_FIXED &amp;&amp;
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      assert(self._handle, 'zlib binding closed');
      self._handle.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Deflate.super_.prototype.reset" id="apidoc.element.mz.zlib.Deflate.super_.prototype.reset">
        function <span class="apidocSignatureSpan">mz.zlib.Deflate.super_.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  assert(this._handle, 'zlib binding closed');
  return this._handle.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.DeflateRaw" id="apidoc.module.mz.zlib.DeflateRaw">module mz.zlib.DeflateRaw</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.DeflateRaw.DeflateRaw" id="apidoc.element.mz.zlib.DeflateRaw.DeflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>DeflateRaw
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.DeflateRaw.super_" id="apidoc.element.mz.zlib.DeflateRaw.super_">
        function <span class="apidocSignatureSpan">mz.zlib.DeflateRaw.</span>super_
        <span class="apidocSignatureSpan">(opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ?
    opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize &lt; exports.Z_MIN_CHUNK ||
        opts.chunkSize &gt; exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS ||
        opts.windowBits &gt; exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level &lt; exports.Z_MIN_LEVEL ||
        opts.level &gt; exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL ||
        opts.memLevel &gt; exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &amp;&amp;
        opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
        opts.strategy != exports.Z_RLE &amp;&amp;
        opts.strategy != exports.Z_FIXED &amp;&amp;
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: () =&gt; { return !this._handle; },
    configurable: true,
    enumerable: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Gunzip" id="apidoc.module.mz.zlib.Gunzip">module mz.zlib.Gunzip</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Gunzip.Gunzip" id="apidoc.element.mz.zlib.Gunzip.Gunzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Gunzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Gunzip.super_" id="apidoc.element.mz.zlib.Gunzip.super_">
        function <span class="apidocSignatureSpan">mz.zlib.Gunzip.</span>super_
        <span class="apidocSignatureSpan">(opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ?
    opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize &lt; exports.Z_MIN_CHUNK ||
        opts.chunkSize &gt; exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS ||
        opts.windowBits &gt; exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level &lt; exports.Z_MIN_LEVEL ||
        opts.level &gt; exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL ||
        opts.memLevel &gt; exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &amp;&amp;
        opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
        opts.strategy != exports.Z_RLE &amp;&amp;
        opts.strategy != exports.Z_FIXED &amp;&amp;
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: () =&gt; { return !this._handle; },
    configurable: true,
    enumerable: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Gzip" id="apidoc.module.mz.zlib.Gzip">module mz.zlib.Gzip</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Gzip.Gzip" id="apidoc.element.mz.zlib.Gzip.Gzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Gzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Gzip.super_" id="apidoc.element.mz.zlib.Gzip.super_">
        function <span class="apidocSignatureSpan">mz.zlib.Gzip.</span>super_
        <span class="apidocSignatureSpan">(opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ?
    opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize &lt; exports.Z_MIN_CHUNK ||
        opts.chunkSize &gt; exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS ||
        opts.windowBits &gt; exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level &lt; exports.Z_MIN_LEVEL ||
        opts.level &gt; exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL ||
        opts.memLevel &gt; exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &amp;&amp;
        opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
        opts.strategy != exports.Z_RLE &amp;&amp;
        opts.strategy != exports.Z_FIXED &amp;&amp;
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: () =&gt; { return !this._handle; },
    configurable: true,
    enumerable: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Inflate" id="apidoc.module.mz.zlib.Inflate">module mz.zlib.Inflate</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Inflate.Inflate" id="apidoc.element.mz.zlib.Inflate.Inflate">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Inflate
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Inflate.super_" id="apidoc.element.mz.zlib.Inflate.super_">
        function <span class="apidocSignatureSpan">mz.zlib.Inflate.</span>super_
        <span class="apidocSignatureSpan">(opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ?
    opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize &lt; exports.Z_MIN_CHUNK ||
        opts.chunkSize &gt; exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS ||
        opts.windowBits &gt; exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level &lt; exports.Z_MIN_LEVEL ||
        opts.level &gt; exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL ||
        opts.memLevel &gt; exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &amp;&amp;
        opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
        opts.strategy != exports.Z_RLE &amp;&amp;
        opts.strategy != exports.Z_FIXED &amp;&amp;
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: () =&gt; { return !this._handle; },
    configurable: true,
    enumerable: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.InflateRaw" id="apidoc.module.mz.zlib.InflateRaw">module mz.zlib.InflateRaw</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.InflateRaw.InflateRaw" id="apidoc.element.mz.zlib.InflateRaw.InflateRaw">
        function <span class="apidocSignatureSpan">mz.zlib.</span>InflateRaw
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.InflateRaw.super_" id="apidoc.element.mz.zlib.InflateRaw.super_">
        function <span class="apidocSignatureSpan">mz.zlib.InflateRaw.</span>super_
        <span class="apidocSignatureSpan">(opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ?
    opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize &lt; exports.Z_MIN_CHUNK ||
        opts.chunkSize &gt; exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS ||
        opts.windowBits &gt; exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level &lt; exports.Z_MIN_LEVEL ||
        opts.level &gt; exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL ||
        opts.memLevel &gt; exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &amp;&amp;
        opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
        opts.strategy != exports.Z_RLE &amp;&amp;
        opts.strategy != exports.Z_FIXED &amp;&amp;
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: () =&gt; { return !this._handle; },
    configurable: true,
    enumerable: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Unzip" id="apidoc.module.mz.zlib.Unzip">module mz.zlib.Unzip</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Unzip.Unzip" id="apidoc.element.mz.zlib.Unzip.Unzip">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Unzip
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Unzip.super_" id="apidoc.element.mz.zlib.Unzip.super_">
        function <span class="apidocSignatureSpan">mz.zlib.Unzip.</span>super_
        <span class="apidocSignatureSpan">(opts, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ?
    opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize &lt; exports.Z_MIN_CHUNK ||
        opts.chunkSize &gt; exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS ||
        opts.windowBits &gt; exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level &lt; exports.Z_MIN_LEVEL ||
        opts.level &gt; exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL ||
        opts.memLevel &gt; exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &amp;&amp;
        opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp;
        opts.strategy != exports.Z_RLE &amp;&amp;
        opts.strategy != exports.Z_FIXED &amp;&amp;
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: () =&gt; { return !this._handle; },
    configurable: true,
    enumerable: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Zlib" id="apidoc.module.mz.zlib.Zlib">module mz.zlib.Zlib</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib.Zlib" id="apidoc.element.mz.zlib.Zlib.Zlib">
        function <span class="apidocSignatureSpan">mz.zlib.</span>Zlib
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zlib() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mz.zlib.Zlib.prototype" id="apidoc.module.mz.zlib.Zlib.prototype">module mz.zlib.Zlib.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib.prototype.close" id="apidoc.element.mz.zlib.Zlib.prototype.close">
        function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib.prototype.init" id="apidoc.element.mz.zlib.Zlib.prototype.init">
        function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function init() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib.prototype.params" id="apidoc.element.mz.zlib.Zlib.prototype.params">
        function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function params() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib.prototype.reset" id="apidoc.element.mz.zlib.Zlib.prototype.reset">
        function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib.prototype.write" id="apidoc.element.mz.zlib.Zlib.prototype.write">
        function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mz.zlib.Zlib.prototype.writeSync" id="apidoc.element.mz.zlib.Zlib.prototype.writeSync">
        function <span class="apidocSignatureSpan">mz.zlib.Zlib.prototype.</span>writeSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeSync() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>